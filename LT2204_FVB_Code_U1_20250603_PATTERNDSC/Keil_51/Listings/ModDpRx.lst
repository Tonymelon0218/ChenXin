C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MODDPRX
OBJECT MODULE PLACED IN .\Objects\ModDpRx.obj
COMPILER INVOKED BY: D:\DevTools\Keil_5\Keil_v5\C51\BIN\C51.EXE ..\User\L1_Module\ModDpRx.c LARGE OBJECTADVANCED OPTIMIZ
                    -E(11,SIZE) REGFILE(.\Objects\LT6911GXD_Pattern_MIPI_C-PHY_2D_NoBurst_2160x2160@120_251121_02.ORC) BROWSE INCDIR(..\User\
                    -L0_App;..\User\L1_Module;..\User\L2_Drive;..\User\L3_Ocm) DEBUG PRINT(.\Listings\ModDpRx.lst) OBJECT(.\Objects\ModDpRx.o
                    -bj)

line level    source

   1          /******************************************************************************
   2            * @project: LT2101
   3            * @file: ChipDpRx.c
   4            * @author: qihan
   5            * @company: LONTIUM
   6            * @date: 2021.10.12
   7          /******************************************************************************/
   8          #include "include.h"
   9          
  10          #if RX_PORT_SIGN == DP_PORT
  11          
  12          #define DPRX_MSAMODE BKF3_05_REG
  13          #define DPRX_HTOTAL_H8 BKF3_06_REG
  14          #define DPRX_HTOTAL_L8 BKF3_07_REG
  15          
  16          #define PPS_VERSION BKEE_00_REG
  17          #define PPS_COLORDEPTH BKEE_03_REG
  18          #define PPS_INFOLOAD BKEE_AD_REG
  19          StructDpRx g_stDpRx;
  20          
  21          void Mod_DpRx_PowerOnInit(void)
  22          {
  23   1          memset(&g_stDpRx, 0, sizeof(StructDpRx));
  24   1          g_stDpRx.ucRxState = STATE_DPRX_POWER_ON_1;
  25   1      }
  26          
  27          void Mod_DpRx_GpioInit(void)
  28          {
  29   1      #if CHIP_SEL == LT8711GXE
                  LT8711GXE_CCGpioInit();
              #endif
  32   1      #if ((CHIP_SEL == LT7911UXE_DP) || (CHIP_SEL == LT6911GXD_DP))
  33   1          LT7911GXE_CCGpioInit();
  34   1      #endif
  35   1      }
  36          
  37          void Mod_DpRx_DpOrTypecDet(void)
  38          {
  39   1      #if CHIP_SEL == LT8711GXE
                  LT8711GXE_DpRxDpOrTypecDet();
              #endif
  42   1      
  43   1      #if ((CHIP_SEL == LT7911UXE_DP) || (CHIP_SEL == LT6911GXD_DP))
  44   1          LT7911GXE_DpRxDpOrTypecDet();
  45   1      #endif
  46   1      }
  47          
  48          void Mod_DpRx_VarInit(void)
  49          {
  50   1      #if CHIP_SEL == LT8711GXE
                  LT8711GXE_DpRxVarInit();
              #endif
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 2   

  53   1      #if ((CHIP_SEL == LT7911UXE_DP) || (CHIP_SEL == LT6911GXD_DP))
  54   1          LT7911GXE_DpRxVarInit();
  55   1      #endif
  56   1      }
  57          
  58          void Mod_DpRx_MsgNotify(u8 ucEvent)
  59          {
  60   1      #if CHIP_SEL == LT8711GXE
                  LT8711GXE_DpRxMsgNotify(ucEvent);
              #endif
  63   1      #if ((CHIP_SEL == LT7911UXE_DP) || (CHIP_SEL == LT6911GXD_DP))
  64   1          LT7911GXE_DpRxMsgNotify(ucEvent);
  65   1      #endif
  66   1      }
  67          
  68          #if DPRX_LINK_CTS == ENABLED
              u8 Mod_DpRx_UpStreamVidReadyGet()
              {
                  return g_stHdmiTx.b1UpstreamVideoReady;
              }
              #endif
  74          
  75          u8 Mod_DpRx_SourceDetection(void)
  76          {
  77   1          if (g_stDpRx.b1Input_Type_Sel == DP_INTF)
  78   1          {
  79   2              return Drv_DpRx_AuxDcDet();
  80   2          }
  81   1      #if TYPECRX_EN == ENABLED
                  else if (g_stDpRx.b1Input_Type_Sel == TYPEC_INTF)
                  {
                      return Mod_CC1ComDone_Get();
                  }
              #endif
  87   1      
  88   1          return FALSE;
  89   1      }
  90          
  91          void Mod_DpRx_SourceChannelSet(void)
  92          {
  93   1          if (g_stDpRx.b1Input_Type_Sel == DP_INTF)
  94   1          {
  95   2              Drv_DpRx_DpRxChlSwap();
  96   2              Drv_DpRx_HpdSet(HPD_HIGH, IRQ_LOW);
  97   2          }
  98   1      #if TYPECRX_EN == ENABLED
                  else
                  {
                      if (UCCStatus.b1UCcInput_type == MALE)
                      {
                          Drv_DpRx_TypecRxChlSwap(TYPEC_MALE, UCCStatus);
                      }
                      else
                      {
                          if (UCCStatus.b1IsFlip == FALSE)
                          {
                              Drv_DpRx_TypecRxChlSwap(TYPEC_FEMALE_NOFLIP, UCCStatus);
                          }
                          else
                          {
                              Drv_DpRx_TypecRxChlSwap(TYPEC_FEMALE_FLIP, UCCStatus);
                          }
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 3   

                      }
                      UCCStatus.b2AttentionType = ATTENTION_HIGH;
                  }
              #endif
 119   1      }
 120          
 121          void Mod_DpRx_PeakClkCal(void)
 122          {
 123   1          u8 ucBitDepth;
 124   1          u8 b1IsDscSimple422 = FALSE;
 125   1          Drv_System_FmSet(TOP_FM, TOPFM_PCRPLL_PCR_CLK);
 126   1          Ocm_Delay1ms(3); // 为什么要10ms？
 127   1          // get Pixel clock ,not Half one
 128   1          g_stDpRx.ulRxPixelClk = Drv_System_FmGet(TOP_FM, HALF_PIX_CLK) << 1; // Hlaf Pixel clock
 129   1      
 130   1          ucBitDepth = g_stDpRx.ucBitDepth;
 131   1      #if DPRX_DSC_DEC_SUPPORT == ENABLED
                  if (Drv_DpRxDscDec_SwitchGet() == ENABLED)
                  {
                      switch (Drv_DpRxDscDec_ColorDepthGet())
                      {
                      case BPC10:
                      case BPC12:
                          ucBitDepth = DPRX_10BIT_2;
                          break;
                      default:
                          ucBitDepth = DPRX_8BIT_1;
                          break;
                      }
                      if (Drv_DpRxDscDec_ColorSpaceGet() == SIMPLE422_5)
                      {
                          b1IsDscSimple422 = TRUE;
                      }
                  }
              #endif
 150   1          switch (ucBitDepth)
 151   1          {
 152   2          case DPRX_6BIT_0:
 153   2              ucBitDepth = 6;
 154   2              break;
 155   2          case DPRX_10BIT_2:
 156   2              ucBitDepth = 10;
 157   2              break;
 158   2          case DPRX_12BIT_3:
 159   2              ucBitDepth = 12;
 160   2              break;
 161   2          default:
 162   2              ucBitDepth = 8;
 163   2              break;
 164   2          }
 165   1          // not support 16bit
 166   1          // for HDMI output,get TMDS Clock
 167   1          g_stDpRx.ulRxPeakClk = (g_stDpRx.ulRxPixelClk * ucBitDepth) >> 3;
 168   1          //
 169   1          if ((g_stDpRx.ucPixelEncoding == YCbCr422_1) && (b1IsDscSimple422 == FALSE))
 170   1          {
 171   2              g_stDpRx.ulRxPeakClk = (g_stDpRx.ulRxPeakClk << 1) / 3;
 172   2          }
 173   1          else
 174   1          {
 175   2              ;
 176   2          }
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 4   

 177   1      }
 178          
 179          #if DPRX_TIMING_HBE == ENABLED
              u8 Chip_Timing_Check(LtTiming_S stRxTimingInfo)
              {
                  if ((stRxTimingInfo.usHtol >= TIMING_HBE_HTOTAL_4k60Hz_MIN) && (stRxTimingInfo.usHtol <= TIMING_HBE_HT
             -OTAL_4k60Hz_MAX))
                  {
                      return HBE_4K60;
                  }
                  else if ((stRxTimingInfo.usHtol >= TIMING_HBE_HTOTAL_4k50Hz_MIN) && (stRxTimingInfo.usHtol <= TIMING_H
             -BE_HTOTAL_4k50Hz_MAX))
                  {
                      return HBE_4K50;
                  }
                  return HBE_NONE;
              }
              u8 Chip_DpRx_JudgeTimingHBE(void)
              {
                  LtTiming_S stRxTimingInfo;
                  // get MSA info from SDP register.
                  Drv_DpRx_RxTimingGet(&stRxTimingInfo);
              
                  if ((Chip_Timing_Check(stRxTimingInfo) == HBE_4K60) && (stRxTimingInfo.usVtol == 2250) && (stRxTimingI
             -nfo.usHact == 3840) && (stRxTimingInfo.usVact == 2160))
                  {
                      g_stDpRx.b2IsTimingHBE = HBE_TYPE_UHD_60Hz;
                  }
                  else if (((Chip_Timing_Check(stRxTimingInfo) == HBE_4K50) && (stRxTimingInfo.usVtol == 2250) && ((stRx
             -TimingInfo.usHact == 3840) || (stRxTimingInfo.usHact == 4096)) && (stRxTimingInfo.usVact == 2160)))
                  {
                      if (stRxTimingInfo.usHact == 3840)
                      {
                          g_stDpRx.b2IsTimingHBE = HBE_TYPE_UHD_50Hz;
                      }
                      else if (stRxTimingInfo.usHact == 4096)
                      {
                          g_stDpRx.b2IsTimingHBE = HBE_TYPE_4K2K_50Hz;
                      }
                  }
                  else
                  {
                      g_stDpRx.b2IsTimingHBE = HBE_NONE;
                  }
                  return g_stDpRx.b2IsTimingHBE;
              }
              
              void Chip_DpRx_TimingHBE(void)
              {
                  u8 usTiming594M_H_Type1[8] = {0x11, 0x30, 0x01, 0x7c, 0x00, 0x58, 0x0F, 0x00};
                  u8 usTiming594M_H_Type2[8] = {0x14, 0xA0, 0x01, 0x7C, 0x00, 0x58, 0x0F, 0x00};
                  u8 usTiming594M_H_Type3[8] = {0x14, 0xA0, 0x00, 0xD4, 0x00, 0x58, 0x10, 0x00};
                  u8 usTiming594M_V[8] = {0x08, 0xCA, 0x00, 0x52, 0x00, 0x0A, 0x08, 0x70};
                  u8 ucTmpF30A;
              
                  ucTmpF30A = BKF3_0A_REG & 0x80;
                  if (g_stDpRx.b2IsTimingHBE == HBE_TYPE_UHD_60Hz)
                  {
                      memcpy(&BKF3_06_REG, &usTiming594M_H_Type1[0], 8);
                  }
                  else if (g_stDpRx.b2IsTimingHBE == HBE_TYPE_UHD_50Hz)
                  {
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 5   

                      memcpy(&BKF3_06_REG, &usTiming594M_H_Type2[0], 8);
                  }
                  else if (g_stDpRx.b2IsTimingHBE == HBE_TYPE_4K2K_50Hz)
                  {
                      memcpy(&BKF3_06_REG, &usTiming594M_H_Type3[0], 8);
                  }
                  BKF3_0A_REG &= 0x7f; // clear bit0-7,default not 0
                  BKF3_0A_REG |= ucTmpF30A;
              
                  memcpy(&BKF3_0E_REG, &usTiming594M_V[0], 8);
              
                  BKF3_05_REG |= BIT6_1; // soft msa enable
                  BKF3_00_REG = 0x80;    // 如果8K HBE需要改成D0
              }
              #endif
 250          
 251          bool Mod_DpRx_PcrColorSpaceUpdate(void)
 252          {
 253   1          //    u8 ucPixelDepth;
 254   1          ColorInfo_S stColorInfo;
 255   1          Drv_DpRx_VidColorInfoGet(&stColorInfo);
 256   1          // no need updata.
 257   1          if ((g_stDpRx.ucPixelEncoding == stColorInfo.ucPixelEncoding) &&
 258   1              //        (g_stDpRx.ucColorimetryFormat == stColorInfo.ucColorimetryFormat) &&
 259   1              (g_stDpRx.ucBitDepth == stColorInfo.ucBitDepth) &&
 260   1              (g_stDpRx.b1VscPkg == stColorInfo.b1VscPkg))
 261   1          {
 262   2              return FALSE;
 263   2          }
 264   1      
 265   1          // colorspace info need to be updata.
 266   1          g_stDpRx.b1VscPkg = stColorInfo.b1VscPkg;
 267   1          g_stDpRx.ucPixelEncoding = stColorInfo.ucPixelEncoding; // 00 rgb 01 ycc422 10 ycc444 11 ycc420
 268   1          g_stDpRx.ucColorimetryFormat = stColorInfo.ucColorimetryFormat;
 269   1          g_stDpRx.ucBitDepth = stColorInfo.ucBitDepth; // 1-8bit, 2-10bit, 3-12bit
 270   1      
 271   1          if (g_stDpRx.b1VscPkg == TRUE)
 272   1          {
 273   2              Drv_DpRx_420DetectMode(HARDWARE);
 274   2          }
 275   1          else
 276   1          {
 277   2              Drv_DpRx_420DetectMode(SOFTMODE);
 278   2          }
 279   1      #if DPRX_MST_MODE_EN == ENABLED
                  if (g_stAuxStatus.b1MstFlag == TRUE)
                  {
                      BKF3_16_REG = 0x80 | (BKF3_16_REG & 0x1f); //[7:5]the value of lane_cnt in soft mode: 100'b-4lane
                      BKF3_12_REG |= BIT7_1;                     //[7]rg_lane_cnt_soft_mode: 1-soft en, 0-soft dis
                  }
                  else
                  {
                      BKF3_16_REG &= 0x1f;   //[7:5]the value of lane_cnt in soft mode: 100'b-4lane
                      BKF3_12_REG &= BIT7_0; //[7]rg_lane_cnt_soft_mode: 1-soft en, 0-soft dis
                  }
              #endif
 291   1          return TRUE;
 292   1      }
 293          
 294          void Mod_DpRx_ColorimetryUpdata(void)
 295          {
 296   1          ColorInfo_S stColorInfo;
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 6   

 297   1          Drv_DpRx_VidColorInfoGet(&stColorInfo);
 298   1          // no need updata.
 299   1          if (g_stDpRx.ucColorimetryFormat == stColorInfo.ucColorimetryFormat)
 300   1          {
 301   2              return;
 302   2          }
 303   1          // colorspace info need to be updata.
 304   1          g_stDpRx.ucColorimetryFormat = stColorInfo.ucColorimetryFormat;
 305   1          printLT(PRINT_PRIO_HIG, "\nColorimetry change = 0x%02bx", g_stDpRx.ucColorimetryFormat);
 306   1          Mod_DpRx_MsgNotify(DPRX_COLORRIMETRY_CHG_EVENT);
 307   1      }
 308          
 309          #if (DPRX_TIMING_HBE == ENABLED)
              //========================================================================
              // Func Name   : Mod_DpRx_JudgeTimingHBE
              // Description : judge is not Horizontal Blanking Expansion
              //                  v direction is same as 4k60 594M,vtotal is 2250,vactive is 2160
              //                  H direction is not same, htotal is 3930~3940, hblank is 90~100,hactive is 3840
              // Input       : void
              // Output      : None
              // Return      : bool
              //========================================================================
              u8 Mod_DpRx_JudgeTimingHBE(void)
              {
                  return g_stDpRx.b2IsTimingHBE;
              }
              #endif
 324          
 325          bool Mod_DpRx_PcrMsaUpdate(void)
 326          {
 327   1          LtTiming_S stRxTimingInfo;
 328   1          if (Drv_System_IntFlagGet(IRQ_DPRX_MSA_INT) == FALSE)
 329   1          {
 330   2              return UNKNOWN;
 331   2          }
 332   1          Drv_DpRx_RxTimingGet(&stRxTimingInfo);
 333   1          if ((g_stDpRx.usHotal == stRxTimingInfo.usHtol) && (g_stDpRx.usHactive == stRxTimingInfo.usHact))
 334   1          {
 335   2              return FALSE; // msa not chg
 336   2          }
 337   1          g_stDpRx.usHotal = stRxTimingInfo.usHtol;
 338   1          g_stDpRx.usHactive = stRxTimingInfo.usHact;
 339   1          return TRUE;
 340   1      }
 341          
 342          void Mod_DpRx_InfoDisplay(void)
 343          {
 344   1          LtTiming_S stTiming;
 345   1          Drv_DpRx_RxTimingGet(&stTiming);
 346   1      
 347   1          printLT(PRINT_PRIO_HIG, "\nDpRxINFO:");
 348   1          printLT(PRINT_PRIO_TEST, "\nHbp    : %-8d  Vbp    : %-8d", stTiming.usHbp, stTiming.usVbp);
 349   1          printLT(PRINT_PRIO_TEST, "\nHfp    : %-8d  Vfp    : %-8d", stTiming.usHfp, stTiming.usVfp);
 350   1          printLT(PRINT_PRIO_TEST, "\nHsync  : %-8d  Vsync  : %-8d", stTiming.usHsync, stTiming.usVsync);
 351   1          printLT(PRINT_PRIO_TEST, "\nHact   : %-8d  Vact   : %-8d", stTiming.usHact, stTiming.usVact);
 352   1          printLT(PRINT_PRIO_TEST, "\nHtol   : %-8d  Vtol   : %-8d", stTiming.usHtol, stTiming.usVtol);
 353   1          printLT(PRINT_PRIO_TEST, "\nDepth  : %-8bd  Space  : %-8bd", (g_stDpRx.ucBitDepth << 1) + 6, g_stDpRx.
             -ucPixelEncoding);
 354   1          printLT(PRINT_PRIO_TEST, "\nPixClk : %-8ld  PeakClk: %-8ld", g_stDpRx.ulRxPixelClk, g_stDpRx.ulRxPeakC
             -lk);
 355   1      }
 356          
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 7   

 357          void Mod_DpRx_FrameRate_Get(LtTiming_S *pstRxTimingInfo)
 358          {
 359   1          u32 ulPixelClock;
 360   1          u16 usHcTotal = 0x00;
 361   1          // soft MSA，包括DSC BYpass，HBE模式等
 362   1          if (DPRX_MSAMODE & BIT6_1) // soft MSA
 363   1          {
 364   2              usHcTotal = ((u16)DPRX_HTOTAL_H8 << 8) + DPRX_HTOTAL_L8;
 365   2          }
 366   1          else
 367   1          {
 368   2              usHcTotal = pstRxTimingInfo->usHtol;
 369   2          }
 370   1          ulPixelClock = (u32)usHcTotal * pstRxTimingInfo->usVtol;
 371   1          //  printLT(PRINT_PRIO_TEST, "\nulRxPixelClk = 0x%08lx", g_stDpRx.ulRxPixelClk);
 372   1          //  printLT(PRINT_PRIO_TEST, "\nulPixelClock = 0x%08lx", ulPixelClock);
 373   1          // if 420 mode and frame rate is EVEN, it is better Multiplication before division
 374   1          if (g_stDpRx.ucPixelEncoding == YCbCr420_3) //
 375   1          {
 376   2              // pstRxTimingInfo->usFramerate = (((g_stDpRx.ulRxPixelClk * 2000)+(ulPixelClock/2))/ulPixelClock)
             -;//四舍五入
 377   2              pstRxTimingInfo->usFramerate = floor((((float)g_stDpRx.ulRxPixelClk * 2000) / ulPixelClock) + 0.5)
             -; // 四舍五入
 378   2          }
 379   1          else
 380   1          {
 381   2              // pstRxTimingInfo->usFramerate = (((g_stDpRx.ulRxPixelClk * 1000)+ulPixelClock/2)/ulPixelClock);/
             -/四舍五入
 382   2              pstRxTimingInfo->usFramerate = floor((((float)g_stDpRx.ulRxPixelClk * 1000) / ulPixelClock) + 0.5)
             -; // 四舍五入
 383   2          }
 384   1          printLT(PRINT_PRIO_TEST, "\nRefreshRate = %d", pstRxTimingInfo->usFramerate);
 385   1      }
 386          
 387          void Mod_DpRx_HpdLowAction(void)
 388          {
 389   1          // pull hpd to low.
 390   1          if (g_stDpRx.b1Input_Type_Sel == DP_INTF)
 391   1          {
 392   2              Drv_DpRx_HpdSet(HPD_LOW, IRQ_LOW);
 393   2          }
 394   1      #if TYPECRX_EN == ENABLED
                  else
                  {
                      UCCStatus.b2AttentionType = ATTENTION_LOW;
                  }
              #endif
 400   1      
 401   1      #if DPRX_HDCP_DEC_MODE != NO_HDCP
                  Drv_System_IntSet(IRQ_RXHDCP1X_INT, OFF); //
                  Drv_System_IntSet(IRQ_RXHDCP2X_INT, OFF); //
                  Drv_HdcpRx_StateClear();
              #endif
 406   1      
 407   1          Drv_DpRx_PhyShut();
 408   1          Drv_DpRx_Reset(DP_FEC_DEC_RST);
 409   1          Drv_DpRx_Reset(DP_MLC_DAT_RST);  // solve mst dpcd200c not clr issue
 410   1          Drv_DpRx_Reset(DP_MLC_DPCD_RST); // solve 3080 mst dpcd not clr issue
 411   1          // DP_MLC_DAT_RST 后需要至少加2ms复位再关掉RXPHY
 412   1          //    Ocm_Delay1ms(10);
 413   1          g_stDpRx.ucHdcpVersion = NO_HDCP;
 414   1          Mod_DpRx_MsgNotify(DPRX_HDCP_VER_CHG_EVENT);
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 8   

 415   1          Mod_DpRx_MsgNotify(DPRX_VIDEO_OFF_EVENT);
 416   1      }
 417          
 418          void Mod_DpRx_HpdIrq(void)
 419          {
 420   1          if (g_stDpRx.b1Input_Type_Sel == DP_INTF)
 421   1          {
 422   2              Drv_DpRx_HpdSet(HPD_HIGH, IRQ_HIGH);
 423   2          }
 424   1      #if TYPECRX_EN == ENABLED
                  else
                  {
                      UCCStatus.b2AttentionType = ATTENTION_IRQ;
                  }
              #endif
 430   1      }
 431          #if DPRX_MST_MODE_EN == ENABLED
              void Mod_DpRx_MstHandler(void)
              {
                  if (g_stDpRx.ucRxState > STATE_DPRX_SET_HPD_5)
                  {
                      Mod_Mst_MsgHandle();
                  }
              }
              #endif
 440          u8 Mod_DpRx_ColorSpace(void)
 441          {
 442   1          return g_stDpRx.ucPixelEncoding;
 443   1      }
 444          
 445          u8 Mod_DpRx_ColorDepth(void)
 446          {
 447   1          return g_stDpRx.ucBitDepth;
 448   1      }
 449          
 450          void Mod_DpRx_SetState(u8 ucState)
 451          {
 452   1          u8 ucLastState;
 453   1          if (ucState != g_stDpRx.ucRxState)
 454   1          {
 455   2              ucLastState = g_stDpRx.ucRxState;
 456   2              g_stDpRx.ucRxState = ucState;
 457   2              g_stDpRx.b1RxStateChanged = TRUE;
 458   2              printLT(PRINT_PRIO_TEST, "\nRxState = %bd", ucState);
 459   2      
 460   2              // other state-->STATE_DPRX_PLAY_BACK_16,need notify video on
 461   2              if (g_stDpRx.ucRxState == STATE_DPRX_PLAY_BACK_16)
 462   2              {
 463   3                  Mod_DpRx_MsgNotify(DPRX_VIDEO_ON_EVENT);
 464   3              }
 465   2      
 466   2              // STATE_DPRX_PLAY_BACK_16-->other state,need notify video off
 467   2              if (ucLastState == STATE_DPRX_PLAY_BACK_16)
 468   2              {
 469   3                  Mod_DpRx_MsgNotify(DPRX_VIDEO_OFF_EVENT);
 470   3              }
 471   2          }
 472   1      }
 473          
 474          //========================================================================
 475          // Func Name   : Mod_DpRx_SourceDetProc
 476          // Description : The process of source detection.
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 9   

 477          // Input       : void
 478          // Output      : None
 479          // Return      : void
 480          //========================================================================
 481          void Mod_DpRx_SourceDetProc(void)
 482          {
 483   1          if (g_stDpRx.ucRxState < STATE_DPRX_WAIT_SOURCE_3)
 484   1          {
 485   2              return;
 486   2          }
 487   1          // the last source detect is high.
 488   1          if (g_stDpRx.b1SourceDet == HIGH)
 489   1          {
 490   2              // the current source detect is low.
 491   2              if (Mod_DpRx_SourceDetection() == FALSE)
 492   2              {
 493   3                  printLT(PRINT_PRIO_HIG, "\nDpRx Unplug");
 494   3                  Mod_DpRx_SetState(STATE_DPRX_WAIT_SOURCE_3); // Typec Rx CC is done or dp is ok cc is open 09
 495   3                  Mod_DpRx_HpdLowAction();
 496   3                  g_stDpRx.b1SourceDet = LOW;
 497   3                  Mod_DpRx_MsgNotify(DPRX_SOURECE_UNPLUG_EVENT);
 498   3              }
 499   2          }
 500   1          // the last source detect is low.
 501   1          else
 502   1          {
 503   2              // the current source detect is high.
 504   2              if (Mod_DpRx_SourceDetection() == TRUE)
 505   2              {
 506   3                  printLT(PRINT_PRIO_HIG, "\nRx Plug");
 507   3                  g_stDpRx.b1SourceDet = HIGH;
 508   3                  Mod_DpRx_MsgNotify(DPRX_SOURECE_PLUG_EVENT);
 509   3              }
 510   2          }
 511   1      }
 512          
 513          void Mod_DpRx_EccErrAbnormalHdl(u8 ucOpt)
 514          {
 515   1          static u8 ucCount = 0;
 516   1      
 517   1          if (ucOpt == DISABLED)
 518   1          {
 519   2              ucCount = 0;
 520   2              return;
 521   2          }
 522   1      
 523   1          if (ucCount >= 0x05) // 1s
 524   1          {
 525   2              ucCount++;
 526   2              if ((Drv_DpRx_NoErrCheck(g_stAuxStatus.ucLink_Count) == TRUE) && (g_stAuxStatus.FecFlag == TRUE))
 527   2              {
 528   3                  printLT(PRINT_PRIO_HIG, "\nWait ECC");
 529   3      #if CHIP_VERSION_SEL == U1_VERSION
                          Drv_DpRx_FecSoftModeSet(TRUE); // Softmode
              #else
 532   3                  // maximum wait time equal ((512*256)/810M)*2 = 324us
 533   3                  Drv_DpRx_FecAbnormalDet();
 534   3      #endif
 535   3              }
 536   2              else
 537   2              {
 538   3                  Drv_DpcdError_Clear(0x0f);
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 10  

 539   3              }
 540   2          }
 541   1          else
 542   1          {
 543   2              ucCount++;
 544   2              Drv_DpRx_Reset(DP_RX_SDP_RST);
 545   2              printLT(PRINT_PRIO_HIG, "\nEcc err");
 546   2          }
 547   1      }
 548          #if ((DPRX_DSC_DEC_SUPPORT == ENABLED) || (DPRX_DSC_BYPASS_SUPPORT == ENABLED))
              u8 Mod_DpRx_DecByp_Sel(void)
              {
                  u32 ulFrequency = 0x00;
                  u8 ucBitDepth = 0x00;
                  u8 ucColorDepth = 0x00;
                  u8 ucSliceNum = 0;
                  //    g_stDpRx.ucDscSel = SELNODSC;
              #if (DPRX_DSC_DEC_SUPPORT == ENABLED)
                  Drv_DpRxDscDec_Set(DISABLED);
              #endif
              #if (DPRX_DSC_BYPASS_SUPPORT == ENABLED)
                  Drv_DpRxDscBy_Set(DISABLED);
              #endif
                  if (Drv_DpRx_PixelStableCheck() == TRUE) // Frequency Stable
                  {
                      // load pps to sram and get color depth
                      Ocm_Delay1us(10);    // must be wait load success
                      PPS_INFOLOAD = 0xff; // important, ee00 ~ ee80 update, must be set
                      Ocm_Delay1ms(1);
                      if ((PPS_VERSION >= 0x11) && (PPS_VERSION <= 0x13))
                      {
                          printLT(PRINT_PRIO_HIG, "\nPPs LOAD SUCCEED");
                      }
                      else
                      {
                          return 0x00; // wait
                      }
                      // color space and depth get
                      ucColorDepth = (PPS_COLORDEPTH >> 5); // 8 bit = 0x04, so >> 4 and /2，is >> 5
                      switch (ucColorDepth)
                      {
                      case BPC10:
                          ucBitDepth = 10;
                          break;
                      case BPC12:
                          ucBitDepth = 12;
                          break;
                      default:
                          ucBitDepth = 8;
                          break;
                      }
                      ulFrequency = Drv_DpRx_PixFreqGet();
                      ulFrequency = (ulFrequency * ucBitDepth) / 4; // 4 = 8/2
                      ucSliceNum = Drv_DpRxDsc_SliceNum();
                      if (ucSliceNum > 4)
                      {
                          printLT(PRINT_PRIO_HIG, "\nSlice >  4");
              #if (DPRX_DSC_BYPASS_SUPPORT == ENABLED)
                          Drv_DpRxDscBy_Set(ENABLED);
              #endif
                          return 0x01; // DSC Judge Done
                      }
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 11  

              
                      if ((ulFrequency > Mod_HdmiTx_LinkBandWidthGet()) && (g_stHdmiEdidInfo.ucMaxFrlDscRate != FRL_NOT_
             -SPT))
                      {
              #if (DPRX_DSC_BYPASS_SUPPORT == ENABLED)
                          Drv_DpRxDscBy_Set(ENABLED);
              #endif
                      }
                      else
                      {
              #if (DPRX_DSC_DEC_SUPPORT == ENABLED)
                          Drv_DpRxDscDec_Set(ENABLED);
              #endif
                      }
                      printLT(PRINT_PRIO_TEST, "\nPixelClock = 0x%08lx, 0x%08lx", ulFrequency, Mod_HdmiTx_LinkBandWidthG
             -et());
                      return 0x01; // DSC Judge Done
                  }
                  else
                  {
                      return 0x00; // wait
                  }
              }
              #endif
 623          void Mod_DpRx_StateJudge(void)
 624          {
 625   1          u8 ucMinState = 0xff;
 626   1      #if DPRX_HDCP_DEC_MODE != NO_HDCP
                  u8 ucHdpcVer;
              #endif
 629   1      #if ((DPRX_LINK_CTS == ENABLED) && (DPRX_DSC_DEC_SUPPORT == ENABLED))
                  u8 ucHpdIrqCnt;
              #endif
 632   1      
 633   1          // source detect low, no need judge
 634   1          if (g_stDpRx.b1SourceDet == LOW)
 635   1          {
 636   2              return;
 637   2          }
 638   1      
 639   1          // monitor down stream is present or not.
 640   1          if (g_stDpRx.ucRxState > STATE_DPRX_DOWNSTREAM_READY_4)
 641   1          {
 642   2              if (g_stDpRx.b1DownstreamDeviceReady == FALSE)
 643   2              {
 644   3                  Mod_DpRx_HpdLowAction(); // pull low hpd.
 645   3                  ucMinState = MIN(ucMinState, STATE_DPRX_DOWNSTREAM_READY_4);
 646   3              }
 647   2          }
 648   1      
 649   1          // monitor re-training event.
 650   1          if (g_stDpRx.ucRxState > STATE_DPRX_WAIT_LINK_TRAIN_6)
 651   1          {
 652   2              if (Mod_Aux_GetRetrainStatus() == TRUE) // re training
 653   2              {
 654   3                  printLT(PRINT_PRIO_HIG, "\nRx re-training");
 655   3                  Mod_DpRx_SetState(STATE_DPRX_WAIT_LINK_TRAIN_6);
 656   3              }
 657   2      #if (DPRX_HDCP_DEC_MODE != NO_HDCP)
                      if ((Drv_Hdcp13_IntGet() == TRUE) || (Drv_Hdcp2X_IntGet() == TRUE))
                      {
                          printLT(PRINT_PRIO_HIG, "\nHDCP INT");
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 12  

                          Mod_DpRx_HpdIrq();
                      }
              #endif
 664   2          }
 665   1      
 666   1      #if DPRX_MST_MODE_EN == ENABLED
                  if (g_stDpRx.ucRxState > STATE_DPRX_WAIT_MST_DONE_7)
                  {
                      if (Mod_DpRxMst_PayloadUpdate() == TRUE)
                      {
                          printLT(PRINT_PRIO_HIG, "\nPayload update");
                          ucMinState = MIN(ucMinState, STATE_DPRX_WAIT_MST_DONE_7); // STATE_DPRX_WAIT_MST_DONE_7;
                      }
                  }
              #endif
 676   1      
 677   1      // monitor fec det
 678   1      #if ((DPRX_FEC_SUPPORT == ENABLED) || (DPRX_DSC_DEC_SUPPORT == ENABLED) || (DPRX_DSC_BYPASS_SUPPORT == ENA
             -BLED))
                  if (g_stDpRx.ucRxState > STATE_DPRX_DESKEW_CHECK_9)
                  {
                      if (Drv_DpRx_FecDecDet() == TRUE)
                      {
                          Drv_DpRx_FecDataPathSet(ENABLED);
                          Drv_DpRx_Reset(DP_FEC_DEC_RST);
                      }
                      else if (Drv_DpRx_FecDecDet() == FALSE)
                      {
                          Drv_DpRx_FecDataPathSet(DISABLED);
                      }
                  }
              #endif
 692   1          if (g_stDpRx.ucRxState == STATE_DPRX_DEPACKET_CHECK_10)
 693   1          {
 694   2              if ((Drv_DpRx_DeSkewCheck() == FAIL) && (g_stAuxStatus.ucLink_Count > ONE_LANE))
 695   2              {
 696   3                  printLT(PRINT_PRIO_HIG, "\nSKew Unlock");
 697   3                  ucMinState = MIN(ucMinState, STATE_DPRX_DESKEW_CHECK_9); //-wangtt- wait confirm
 698   3              }
 699   2          }
 700   1          // monitor MSA changes event and updata MSA info.
 701   1          if (g_stDpRx.ucRxState > STATE_DPRX_MSA_CHECK_11)
 702   1          {
 703   2              // monitor color space changes event and updata color space info.
 704   2              if (Mod_DpRx_PcrColorSpaceUpdate() == TRUE)
 705   2              {
 706   3                  printLT(PRINT_PRIO_HIG, "\nColor space change");
 707   3                  ucMinState = MIN(ucMinState, STATE_DPRX_DEPACKET_CHECK_10); //-wangtt- wait confirm
 708   3              }
 709   2              if (Mod_DpRx_PcrMsaUpdate() == TRUE)
 710   2              {
 711   3                  printLT(PRINT_PRIO_HIG, "\nMsa change");
 712   3                  ucMinState = MIN(ucMinState, STATE_DPRX_DEPACKET_CHECK_10);
 713   3              }
 714   2              if (g_stDpRx.b1CompressedStream != Drv_DpRx_DscDecState())
 715   2              {
 716   3                  printLT(PRINT_PRIO_HIG, "\nDSC CHNG");
 717   3                  ucMinState = MIN(ucMinState, STATE_DPRX_DEPACKET_CHECK_10);
 718   3              }
 719   2          }
 720   1      #if ((DPRX_LINK_CTS == ENABLED) && (DPRX_DSC_DEC_SUPPORT == ENABLED))
                  if (g_stDpRx.ucRxState > STATE_DPRX_PPS_CHECK_12)
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 13  

                  {
                      // slove StemDeck PPS issue,just send PPS packet for a while
                      if (Drv_System_IntFlagGet(IRQ_DPRX_PPS_DATA_CHG_INT) == TRUE)
                      {
                          Drv_System_IntClr(IRQ_DPRX_PPS_DATA_CHG_INT);
                          if (Drv_DpRxDscDec_DscParaCheck() == FALSE)
                          {
                              if (ucHpdIrqCnt == 0)
                              {
                                  Mod_DpRx_HpdIrq();
                                  ucHpdIrqCnt++;
                              }
                          }
                          else
                          {
                              ucHpdIrqCnt = 0;
                          }
                      }
                  }
              #endif
 742   1      
 743   1          // monitor PCR unstable event, just for debug
 744   1          if (g_stDpRx.ucRxState > STATE_DPRX_PCR_CONFIG_13)
 745   1          {
 746   2              if ((Drv_DpRx_PcrStableCheck() == UNSTABLE) || (DRV_DpRx_VideoStreamFlag() == FALSE))
 747   2              {
 748   3                  printLT(PRINT_PRIO_HIG, "\nGoto PCR");
 749   3                  ucMinState = MIN(ucMinState, STATE_DPRX_DEPACKET_CHECK_10);
 750   3              }
 751   2          }
 752   1      
 753   1      // monitor hdcp verison change
 754   1      #if DPRX_HDCP_DEC_MODE != NO_HDCP
                  if (g_stDpRx.ucRxState > STATE_DPRX_HDCP_VER_CHK_14)
                  {
                      ucHdpcVer = Drv_HdcpRx_VerGet();
                      if (g_stDpRx.ucHdcpVersion != ucHdpcVer)
                      {
                          g_stDpRx.ucHdcpVersion = ucHdpcVer;
                          printLT(PRINT_PRIO_TEST, "\nHcdp upate");
                          Mod_DpRx_MsgNotify(DPRX_HDCP_VER_CHG_EVENT);
                      }
                  }
              #endif
 766   1      
 767   1          // monitor audio 8 channel
 768   1          if (g_stDpRx.ucRxState > STATE_DPRX_AUDIO_INFO_CHK_15)
 769   1          {
 770   2              Drv_DpRx_AudioFormatSet();
 771   2              //        if ((Drv_Audio_AcrMute() == FALSE) && (Mod_DpRx_AudioChannelUpdata() == TRUE))
 772   2              if (Drv_Audio_FsValStbCheck() == TRUE)
 773   2              {
 774   3                  Drv_AudioSdm_SwEn();
 775   3                  printLT(PRINT_PRIO_TEST, "\nAudio chg");
 776   3                  Mod_DpRx_MsgNotify(DPRX_AUDIO_CHG_EVENT);
 777   3              }
 778   2      #if DPRX_CDR_MODE == ANACDR
 779   2              if (Drv_DpRxPll_LockGet() == FALSE)
 780   2              {
 781   3                  printLT(PRINT_PRIO_TEST, "\nACDR Unlock");
 782   3                  ucMinState = MIN(ucMinState, STATE_DPRX_DESKEW_CHECK_9);
 783   3              }
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 14  

 784   2      #endif
 785   2      #if DPRX_DSC_DEC_SUPPORT == ENABLED
                      if ((g_stDpRx.ucDscFifoEmpty | g_stDpRx.ucDscFifoEmpty) == 0x00)
                      {
                          if ((g_stDpRx.ucDscFifoEmpty != Drv_DpRx_DscFifoEmptyGet()) || (g_stDpRx.ucDscFifoFull != Drv_
             -DpRx_DscFifoFullGet()))
                          {
                              Drv_DpRxDscDec_Rst();
                              printLT(PRINT_PRIO_TEST, "\nDSCFIFO ERR");
              
                              //                ucMinState = MIN(ucMinState, STATE_DPRX_DESKEW_CHECK_9);
                          }
                      }
              #endif
 797   2          }
 798   1          // monitor hdr
 799   1          if ((g_stDpRx.ucRxState >= STATE_DPRX_PLAY_BACK_16) && (ucMinState >= STATE_DPRX_PLAY_BACK_16))
 800   1          {
 801   2              // monitor dobly hdr
 802   2              if ((Drv_System_IntFlagGet(IRQ_DPRX_VSI_INT) == TRUE))
 803   2              {
 804   3                  Drv_System_IntClr(IRQ_DPRX_VSI_INT);
 805   3                  g_stDpRx.b1HdrEn = ENABLED;
 806   3                  Mod_DpRx_MsgNotify(DPRX_DOBLY_HDR_NOTIFY_EVENT);
 807   3              }
 808   2              // monitor static HDR
 809   2              if (Drv_System_IntFlagGet(IRQ_DPRX_STATICHDR_INT) == TRUE)
 810   2              {
 811   3                  Drv_System_IntClr(IRQ_DPRX_STATICHDR_INT);
 812   3                  g_stDpRx.b1HdrEn = ENABLED;
 813   3                  Mod_DpRx_MsgNotify(DPRX_STATIC_HDR_NOTIFY_EVENT);
 814   3              }
 815   2              // monitor dynamic HDR
 816   2              if (Drv_System_IntFlagGet(IRQ_DPRX_DYNAMICHDR_INT) == TRUE)
 817   2              {
 818   3                  Drv_System_IntClr(IRQ_DPRX_DYNAMICHDR_INT);
 819   3                  g_stDpRx.b1HdrEn = ENABLED;
 820   3                  Mod_DpRx_MsgNotify(DPRX_DYNAMIC_HDR_NOTIFY_EVENT);
 821   3              }
 822   2      // adapter sync
 823   2      #if DPRX_ADAPTIVE_SYNC == ENABLED
                      if (Drv_System_IntFlagGet(IRQ_DPRX_ADAPTIVE_SYNC_INT) == TRUE)
                      {
                          Drv_System_IntClr(IRQ_DPRX_ADAPTIVE_SYNC_INT);
                          g_stAuxStatus.ucMsaIgnoreEn = ENABLED;
                          g_stDpRx.b1AdaptiveSyncEn = ENABLED;
                          Mod_DpRx_MsgNotify(DPRX_VRR_NOTIFY_EVENT);
                      }
                      else if (g_stAuxStatus.ucMsaIgnoreEn & BIT7_1) // DPCD Write 107
                      {
                          g_stAuxStatus.ucMsaIgnoreEn &= BIT7_0; // clear
                          g_stDpRx.b1AdaptiveSyncEn = (g_stAuxStatus.ucMsaIgnoreEn & BIT7_0);
                          Mod_DpRx_MsgNotify(DPRX_VRR_NOTIFY_EVENT);
                      }
              #endif
 838   2          }
 839   1          if (ucMinState != 0xff)
 840   1          {
 841   2              Mod_DpRx_SetState(ucMinState);
 842   2          }
 843   1      }
 844          
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 15  

 845          void Mod_DpRx_StateHandler(void)
 846          {
 847   1          static u32 ulCurrentTime = 0;
 848   1      #if ((DPRX_DSC_DEC_SUPPORT == ENABLED) || (DPRX_DSC_BYPASS_SUPPORT == ENABLED))
                  static u8 b1DscPpsDone = NOT_SUPPORT;
                  static u8 ucTryToLoadPPS = 0x00;
              #endif
 852   1          static u8 ucWaitPcrStableCnt;
 853   1          //    static u8 ucDscSelect = 0x00;
 854   1          switch (g_stDpRx.ucRxState)
 855   1          {
 856   2          case STATE_DPRX_POWER_ON_1:
 857   2              Mod_DpRx_GpioInit();
 858   2      #if TYPECRX_EN == ENABLED
                      DRV_CCPHY_DigSet();
              #endif
 861   2              Drv_DpRx_PowerOnInit();
 862   2              Drv_DpRx_PhyShut(); // close Rterm for USB3.0 Switch use
 863   2              Mod_DpRx_SetState(STATE_DPRX_INPUT_TYPE_DET_2);
 864   2              break;
 865   2      
 866   2          case STATE_DPRX_INPUT_TYPE_DET_2:
 867   2              if (g_stDpRx.b1RxStateChanged == TRUE)
 868   2              {
 869   3                  Ocm_Timer_UpdLocalTime(&ulCurrentTime);
 870   3                  g_stDpRx.b1RxStateChanged = FALSE;
 871   3              }
 872   2              if (Ocm_Timer_IsOverFlow(&ulCurrentTime, MS_10) == TRUE)
 873   2              {
 874   3                  Mod_DpRx_DpOrTypecDet();
 875   3                  Mod_DpRx_SetState(STATE_DPRX_WAIT_SOURCE_3);
 876   3              }
 877   2              break;
 878   2      
 879   2          case STATE_DPRX_WAIT_SOURCE_3:
 880   2              if (g_stDpRx.b1SourceDet == HIGH)
 881   2              {
 882   3                  Mod_DpRx_SetState(STATE_DPRX_DOWNSTREAM_READY_4);
 883   3              }
 884   2              break;
 885   2      
 886   2          case STATE_DPRX_DOWNSTREAM_READY_4:
 887   2              if (g_stDpRx.b1DownstreamDeviceReady == TRUE) // hdmi tx edid read OK
 888   2              {
 889   3                  Mod_DpRx_SetState(STATE_DPRX_SET_HPD_5);
 890   3              }
 891   2              break;
 892   2      
 893   2          case STATE_DPRX_SET_HPD_5:
 894   2              if (g_stDpRx.b1RxStateChanged == TRUE)
 895   2              {
 896   3                  Ocm_Timer_UpdLocalTime(&ulCurrentTime);
 897   3                  Drv_Sys_ChipRxSrcSel(CHIPRX_SRC_SEL_DPRX);
 898   3                  g_stDpRx.b1RxStateChanged = FALSE;
 899   3              }
 900   2              if (Ocm_Timer_IsOverFlow(&ulCurrentTime, MS_300) == TRUE)
 901   2              {
 902   3                  Mod_DpRx_VarInit();
 903   3                  Drv_DpRx_SettingInit();
 904   3      #if ((DPRX_DSC_DEC_SUPPORT == ENABLED) || (DPRX_DSC_BYPASS_SUPPORT == ENABLED))
                          // to clear DSC abnormal handle logic
                          g_stDpRx.b1DscAbnormal = FALSE;
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 16  

              #endif
 908   3                  Mod_DpRx_SourceChannelSet();
 909   3                  Mod_DpRx_SetState(STATE_DPRX_WAIT_LINK_TRAIN_6);
 910   3                  Drv_System_IntClr(IRQ_DPRX_PPS_PKT_INT);
 911   3                  Drv_System_IntSet(IRQ_DPRX_PPS_PKT_INT, ON);
 912   3              }
 913   2              break;
 914   2      
 915   2          case STATE_DPRX_WAIT_LINK_TRAIN_6:            // 06
 916   2              if (Mod_Aux_GetTrainDoneStatus() == TRUE) // rx trainig done
 917   2              {
 918   3      #if DPRX_LINK_CTS == ENABLED // solution for DPRX link CTS.//5.3.2.1 IRQ HPD Pulse Due to Loss of Symbol L
             -ock and Clock Recovery Lock
                          if (g_stDpRx.b1RxStateChanged == TRUE)
                          {
                              Ocm_Timer_UpdLocalTime(&ulCurrentTime);
                              Drv_DpcdError_Clear(0x0F);
                              g_stDpRx.b1RxStateChanged = FALSE;
                          }
              
                          if (Mod_DpRx_8b10bErrorChk() == TRUE)
                          {
                              printLT(PRINT_PRIO_HIG, "\nloss lock");
                              Mod_Aux_DealLossLock();
                              Mod_DpRx_HpdIrq();
              #if ((DPRX_FEC_SUPPORT == ENABLED) || (DPRX_DSC_DEC_SUPPORT == ENABLED) || (DPRX_DSC_BYPASS_SUPPORT == ENA
             -BLED))
                              Drv_DpRx_FecSoftModeSet(FALSE);
              #endif
                          }
              #endif
 936   3                  if (Ocm_Timer_IsOverFlow(&ulCurrentTime, MS_20) == TRUE)
 937   3                  {
 938   4      #if DPRX_MST_MODE_EN == ENABLED
                              if (g_stAuxStatus.b1MstFlag == 1)
                              {
                                  Mod_DpRx_SetState(STATE_DPRX_WAIT_MST_DONE_7);
                              }
                              else
              #endif
 945   4                      {
 946   5      
 947   5                          Mod_DpRx_SetState(STATE_DPRX_EQ_FINE_TUNE_8);
 948   5                      }
 949   4                  }
 950   3              }
 951   2              break;
 952   2      
 953   2      #if DPRX_MST_MODE_EN == ENABLED
                  case STATE_DPRX_WAIT_MST_DONE_7:
                      if (g_stDpRx.b1RxStateChanged == TRUE) // 26 bytes
                      {
                          Ocm_Timer_UpdLocalTime(&ulCurrentTime);
                          g_stDpRx.b1RxStateChanged = FALSE;
                      }
                      if (g_stAuxStatus.b1MstFlag == 1)
                      {
                          if ((g_stMstRxStatus.request_flag == 1) || (g_stMstRxStatus.payload_flag == 0) || (Mod_DpRxMst
             -_PayloadDone() == TRUE))
                          {
                              Ocm_Timer_UpdLocalTime(&ulCurrentTime);
                              g_stMstRxStatus.request_flag = 0;
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 17  

                              g_stMstRxStatus.payload_done_flag = 0;
                          }
                          if ((Ocm_Timer_IsOverFlow(&ulCurrentTime, MS_400) == TRUE))
                          {
              #if ((DPRX_FEC_SUPPORT == ENABLED) || (DPRX_DSC_DEC_SUPPORT == ENABLED) || (DPRX_DSC_BYPASS_SUPPORT == ENA
             -BLED))
                              Drv_DpRx_FecSoftModeSet(g_stAuxStatus.FecFlag);
              #endif
                              Mod_DpRx_SetState(STATE_DPRX_EQ_FINE_TUNE_8);
                          }
                      }
                      break;
              #endif
 978   2      
 979   2          case STATE_DPRX_EQ_FINE_TUNE_8:
 980   2              if (g_stDpRx.b1RxStateChanged == TRUE)
 981   2              {
 982   3                  //                Drv_DpcdError_Clear(0x0F);
 983   3      #if ((DPRX_FEC_SUPPORT == ENABLED) || (DPRX_DSC_DEC_SUPPORT == ENABLED) || (DPRX_DSC_BYPASS_SUPPORT == ENA
             -BLED))
                          Drv_DpRx_FecDataPathSet(DISABLED);
              #endif
 986   3                  g_stDpRx.b1RxStateChanged = FALSE;
 987   3                  Ocm_Timer_UpdLocalTime(&ulCurrentTime);
 988   3                  printLT(PRINT_PRIO_TEST, "\nRATE_LANE = 0x%02bx,0x%02bx", g_stAuxStatus.ucLink_Rate, g_stAuxSt
             -atus.ucLink_Count);
 989   3              }
 990   2              if ((Ocm_Timer_IsOverFlow(&ulCurrentTime, MS_800) == TRUE) || (DRV_DpRx_VideoStreamFlag() == TRUE)
             -)
 991   2              {
 992   3                  Mod_DpRx_EqSet();
 993   3                  Mod_DpRx_SetState(STATE_DPRX_DESKEW_CHECK_9);
 994   3              }
 995   2              break;
 996   2      
 997   2          case STATE_DPRX_DESKEW_CHECK_9:
 998   2              if (g_stDpRx.b1RxStateChanged == TRUE)
 999   2              {
1000   3                  g_stDpRx.b1RxStateChanged = FALSE;
1001   3                  Ocm_Timer_UpdLocalTime(&ulCurrentTime);
1002   3              }
1003   2              if (Ocm_Timer_IsOverFlow(&ulCurrentTime, MS_100) == TRUE)
1004   2              {
1005   3                  // one lane has no skew issue
1006   3                  // if((Drv_DpRx_DeSkewCheck() == FAIL)&&(g_stAuxStatus.ucLink_Count > ONE_LANE))
1007   3                  if (Drv_DpRx_DeSkewCheck() == FAIL)
1008   3                  {
1009   4                      Drv_DpRx_Reset(DP_RX_FIFO_RST);
1010   4                      printLT(PRINT_PRIO_HIG, "\nDe-skew err");
1011   4                      Ocm_Timer_UpdLocalTime(&ulCurrentTime);
1012   4                  }
1013   3                  else
1014   3                  {
1015   4                      Mod_DpRx_SetState(STATE_DPRX_DEPACKET_CHECK_10);
1016   4                  }
1017   3              }
1018   2              break;
1019   2      
1020   2          case STATE_DPRX_DEPACKET_CHECK_10:
1021   2              if (g_stDpRx.b1RxStateChanged == TRUE)
1022   2              {
1023   3      #if ((DPRX_FEC_SUPPORT == ENABLED) || (DPRX_DSC_DEC_SUPPORT == ENABLED) || (DPRX_DSC_BYPASS_SUPPORT == ENA
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 18  

             -BLED))
                          Drv_DpRx_FecSoftModeSet(FALSE); // hardmode
              #endif
1026   3      #if (DPRX_TIMING_HBE == ENABLED)
                          g_stDpRx.b2IsTimingHBE = HBE_NONE;
              #endif
1029   3                  // remove sdp reset
1030   3                  // SDP reset is needed in case of Depacket error
1031   3                  // 必须要保留
1032   3                  Drv_DpRx_Reset(DP_RX_SDP_RST); //
1033   3                  Drv_DpRx_Reset(DP_RX_PCR_RST); // New for TEST
1034   3      #if DPRX_DSC_DEC_SUPPORT == ENABLED
                          Drv_DpRxDscDec_Init();
              #endif
1037   3      #if DPRX_DSC_BYPASS_SUPPORT == ENABLED
                          Drv_DpRxDscBy_Init();
              #endif
1040   3                  g_stDpRx.b1RxStateChanged = FALSE;
1041   3                  Mod_DpRx_EccErrAbnormalHdl(DISABLED);
1042   3                  Drv_DpRx_EccErrorCheck();
1043   3                  Ocm_Timer_UpdLocalTime(&ulCurrentTime);
1044   3              }
1045   2              if (Ocm_Timer_IsOverFlow(&ulCurrentTime, MS_100) == TRUE)
1046   2              {
1047   3                  if (Drv_DpRx_EccErrorCheck() == FAIL)
1048   3                  {
1049   4                      Mod_DpRx_EccErrAbnormalHdl(ENABLED);
1050   4                      Ocm_Timer_UpdLocalTime(&ulCurrentTime);
1051   4                  }
1052   3                  else
1053   3                  {
1054   4                      Mod_DpRx_SetState(STATE_DPRX_MSA_CHECK_11);
1055   4                  }
1056   3              }
1057   2              break;
1058   2      
1059   2          case STATE_DPRX_MSA_CHECK_11:
1060   2              if (g_stDpRx.b1RxStateChanged == TRUE)
1061   2              {
1062   3                  Drv_Sys_DecPowerDomain(FALSE);
1063   3                  Drv_DpRx_MsaPktDetEn();
1064   3                  Drv_DpRx_420DetectMode(SOFTMODE);
1065   3                  g_stDpRx.ucPixelEncoding = 0xff;
1066   3                  g_stDpRx.ucColorimetryFormat = 0xff;
1067   3                  g_stDpRx.ucBitDepth = 0xff;
1068   3      #if (DPRX_TIMING_HBE == ENABLED)
                          g_stDpRx.b2IsTimingHBE = HBE_NONE;
              #endif
1071   3                  g_stDpRx.usHotal = 0;
1072   3                  g_stDpRx.usHactive = 0;
1073   3                  g_stDpRx.b1RxStateChanged = FALSE;
1074   3                  g_stDpRx.b1VscPkg = 0x00;
1075   3              }
1076   2              Mod_DpRx_PcrColorSpaceUpdate();
1077   2              if (Mod_DpRx_PcrMsaUpdate() == FALSE)
1078   2              {
1079   3                  if (Drv_DpRx_DscDecState() == ENABLED)
1080   3                  {
1081   4      #if DPRX_DSC_DEC_SUPPORT == ENABLED
                              Drv_DpRxDscDec_RxInit();
                              Drv_DpRxDscDec_ParaInit();
              #endif
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 19  

1085   4      #if DPRX_DSC_BYPASS_SUPPORT == ENABLED
                              //                    Drv_DpRxDscBy_RxInit();
                              Drv_DpRxDscBy_ParaInit();
              #endif
1089   4                      g_stDpRx.b1CompressedStream = ENABLED;
1090   4                      Mod_DpRx_SetState(STATE_DPRX_PPS_CHECK_12);
1091   4                  }
1092   3                  else
1093   3                  {
1094   4      #if DPRX_TIMING_HBE == ENABLED
                              if (Chip_DpRx_JudgeTimingHBE() != HBE_NONE)
                              {
                                  Chip_DpRx_TimingHBE();
                              }
                              else
                              {
                                  ;
                              }
              #endif
1104   4                      Drv_Sys_DecPowerDomain(TRUE);
1105   4                      g_stDpRx.b1CompressedStream = DISABLED;
1106   4                      Mod_DpRx_SetState(STATE_DPRX_PCR_CONFIG_13);
1107   4                  }
1108   3              }
1109   2              break;
1110   2      #if ((DPRX_DSC_DEC_SUPPORT == ENABLED) || (DPRX_DSC_BYPASS_SUPPORT == ENABLED))
                  case STATE_DPRX_PPS_CHECK_12:
                      if (g_stDpRx.b1RxStateChanged == TRUE)
                      {
                          if (Drv_System_IntFlagGet(IRQ_DPRX_PPS_PKT_INT) == TRUE)
                          {
                              ucTryToLoadPPS = 0x80;
                          }
                          else
                          {
                              ucTryToLoadPPS = 0x00;
                          }
                          printLT(PRINT_PRIO_HIG, "\nPPSPKT = 0x%02bx", ucTryToLoadPPS);
                          Ocm_Timer_UpdLocalTime(&ulCurrentTime);
                          g_stDpRx.b1RxStateChanged = FALSE;
                          Drv_System_IntClr(IRQ_DPRX_PPS_PKT_INT);
                          g_stDpRx.b1DscAbnormal = FALSE;
                          b1DscPpsDone = NOT_SUPPORT;
                          //                ucDscSelect = 0x00;
                          Ocm_Timer_UpdLocalTime(&ulCurrentTime);
                      }
                      if (Ocm_Timer_IsOverFlow(&ulCurrentTime, SECOND_2) == TRUE)
                      {
                          if (Drv_DpRx_DscDecState() == ENABLED)
                          {
                              if (Drv_DpRx_PpsInfoCheck() == FAIL)
                              {
                                  g_stDpRx.b1DscAbnormal = TRUE;
                                  Mod_DpRx_SetState(STATE_DPRX_WAIT_SOURCE_3); // Typec Rx CC is done or dp is ok cc is 
             -open 09
                                  Mod_DpRx_HpdLowAction();
                                  g_stDpRx.b1SourceDet = LOW;
                                  Mod_DpRx_MsgNotify(DPRX_SOURECE_UNPLUG_EVENT);
                              }
                          }
              
                          // Mod_DpRx_SetState(STATE_DPRX_DEPACKET_CHECK_10);
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 20  

                      }
                      if (Ocm_Timer_IsOverFlow(&ulCurrentTime, MS_1500) == TRUE)
                      {
                          if (Drv_DpRx_DscDecState() == ENABLED)
                          {
                              ucTryToLoadPPS |= BIT0_1;
                          }
                          else
                          {
                              ucTryToLoadPPS = 0x00;
                          }
                      }
                      if (Ocm_Timer_IsOverFlow(&ulCurrentTime, MS_5) == TRUE)
                      {
                          //                printLT(PRINT_PRIO_HIG, "\nSatble = 0x%02bx,0x%02bx",BKF3_DF_REG,BKF3_E2_REG
             -);
                          //                printLT(PRINT_PRIO_HIG, "\nFreq = 0x%02bx,0x%02bx,0x%02bx",BKF3_F8_REG,BKF3_
             -F9_REG,BKF3_FA_REG);
                          //                Ocm_Timer_UpdLocalTime(&ulCurrentTime);
                          if ((Drv_DpRx_PpsInfoCheck() == SUCCESS) || (ucTryToLoadPPS == 0x81))
                          {
                              if (Mod_DpRx_DecByp_Sel() == 0x00)
                              {
                                  return;
                              }
              #if DPRX_DSC_DEC_SUPPORT == ENABLED
                              //                    if(g_stDpRx.ucDscSel == SELDSCDECODE)//DECODEs
                              if (Drv_DpRxDscDec_SwitchGet() == ENABLED)
                              {
              
                                  Drv_DpRxDscDec_TimingGet();
                                  b1DscPpsDone = Drv_DpRxDscDec_DscInfoGet();
              #if DPRX_LINK_CTS == ENABLED
                                  Drv_DpRx_DscPpsDataChg_IntSet(ENABLED);
                                  Drv_System_IntSet(IRQ_DPRX_PPS_DATA_CHG, ON);
              #endif
                              }
              #endif
              #if DPRX_DSC_BYPASS_SUPPORT == ENABLED
                              if (Drv_DpRxDscBy_SwitchGet() == ENABLED)
                              {
                                  Drv_DpRxDscBy_RxInit();
                                  Drv_DpRxDscBy_TimingGet();
                                  b1DscPpsDone = Drv_DpRxDscBy_DscInfoGet();
                                  Mod_DpRx_SetState(STATE_DPRX_PCR_CONFIG_13);
                              }
              #endif
                              if (b1DscPpsDone == CAN_RUNNING)
                              {
                                  Mod_DpRx_SetState(STATE_DPRX_PCR_CONFIG_13);
                              }
                          }
                      }
                      break;
              #endif
1199   2          case STATE_DPRX_PCR_CONFIG_13:
1200   2              if (g_stDpRx.b1RxStateChanged == TRUE)
1201   2              {
1202   3      #if DPRX_DSC_BYPASS_SUPPORT == ENABLED
                          if (Drv_DpRxDscBy_SwitchGet() == ENABLED)
                          {
                              if (Drv_DpRx_DscDecState() == ENABLED)
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 21  

                              {
                                  Drv_DpRx_SyncPolSet(ENABLED);
                                  Drv_DpRxDscBy_ModuleEnable(); // first dsc bypass en, then pcr stable
                              }
                          }
              #endif
1212   3                  // no need to check MSA again
1213   3                  //                Mod_DpRx_PcrColorSpaceUpdata();
1214   3                  //                Drv_DpRx_Reset(DP_RX_PCR_RST);
1215   3                  Drv_DpRx_VidFreqSetCheck(DISABLED);
1216   3                  Ocm_Timer_UpdLocalTime(&ulCurrentTime);
1217   3                  printLT(PRINT_PRIO_TEST, "\nWait pcr stable...");
1218   3                  g_stDpRx.b1RxStateChanged = FALSE;
1219   3                  ucWaitPcrStableCnt = 0;
1220   3                  //                Drv_DpRx_HsyncPcrErrSet(g_stDpRx);
1221   3              }
1222   2              Drv_DpRx_VidFreqSetCheck(ENABLED);
1223   2              if (Ocm_Timer_IsOverFlow(&ulCurrentTime, MS_100) == TRUE)
1224   2              {
1225   3                  // if (Drv_DpRx_PcrStableCheck() == STABLE)//first pcr stable, then dsc dec
1226   3                  if ((Drv_DpRx_PcrStableCheck() == STABLE) && (DRV_DpRx_VideoStreamFlag() == TRUE))
1227   3                  {
1228   4      #if DPRX_DSC_DEC_SUPPORT == ENABLED
                              if (Drv_DpRxDscDec_SwitchGet() == ENABLED)
                              {
                                  if (Drv_DpRx_DscDecState() == ENABLED)
                                  {
                                      Drv_DpRx_SyncPolSet(ENABLED);
                                      Drv_DpRxDscDec_ModuleEnable();
                                  }
                              }
              #endif
1238   4                      Mod_DpRx_SetState(STATE_DPRX_HDCP_VER_CHK_14);
1239   4                  }
1240   3                  else if (DRV_DpRx_VideoStreamFlag() == FALSE)
1241   3                  {
1242   4                      return;
1243   4                  }
1244   3              }
1245   2              // in case of PCRPLL unlock issue
1246   2              if (Ocm_Timer_IsOverFlow(&ulCurrentTime, MS_500) == TRUE)
1247   2              {
1248   3                  ucWaitPcrStableCnt++;
1249   3                  if (ucWaitPcrStableCnt == 10)
1250   3                  {
1251   4      #if REMOVE_UART == DISABLED
1252   4                      printLT(PRINT_PRIO_HIG, "\nPCR HARD RESET");
1253   4      #endif
1254   4      #if DPRX_PCRPLL_HRST == DISABLED
                              Drv_DpRx_PcrPllRst(ENABLED);
              #endif
1257   4                      Drv_DpRx_Reset(DP_RX_PCR_RST);
1258   4                      Ocm_Delay1ms(2);
1259   4      #if DPRX_PCRPLL_HRST == DISABLED
                              Drv_DpRx_PcrPllRst(DISABLED);
              #endif
1262   4                      ucWaitPcrStableCnt = 0;
1263   4                  }
1264   3                  // DRV_DpRx_VidPcrReset();
1265   3                  Ocm_Timer_UpdLocalTime(&ulCurrentTime);
1266   3              }
1267   2              break;
C51 COMPILER V9.60.0.0   MODDPRX                                                           11/21/2025 11:27:22 PAGE 22  

1268   2      
1269   2          case STATE_DPRX_HDCP_VER_CHK_14:
1270   2              if (g_stDpRx.b1RxStateChanged == TRUE)
1271   2              {
1272   3                  g_stDpRx.ucHdcpVersion = NO_HDCP;
1273   3                  g_stDpRx.b1RxStateChanged = FALSE;
1274   3                  Ocm_Timer_UpdLocalTime(&ulCurrentTime);
1275   3                  g_stDpRx.ucDscFifoEmpty = Drv_DpRx_DscFifoEmptyGet();
1276   3                  g_stDpRx.ucDscFifoFull = Drv_DpRx_DscFifoFullGet();
1277   3              }
1278   2              Mod_DpRx_SetState(STATE_DPRX_AUDIO_INFO_CHK_15);
1279   2              break;
1280   2      
1281   2          case STATE_DPRX_AUDIO_INFO_CHK_15: // 0d
1282   2              if (g_stDpRx.b1RxStateChanged == TRUE)
1283   2              {
1284   3                  g_stDpRx.b1RxStateChanged = FALSE;
1285   3              }
1286   2              Mod_DpRx_SetState(STATE_DPRX_PLAY_BACK_16);
1287   2              break;
1288   2      
1289   2          case STATE_DPRX_PLAY_BACK_16: // 0d
1290   2              Mod_DpRx_ColorimetryUpdata();
1291   2              break;
1292   2      
1293   2          default:
1294   2              break;
1295   2          }
1296   1      }
1297          
1298          void Mod_DpRx_Handler(void)
1299          {
1300   1          Mod_DpRx_SourceDetProc();
1301   1          Mod_DpRx_StateJudge();
1302   1          Mod_DpRx_StateHandler();
1303   1      #if DPRX_MST_MODE_EN == ENABLED
                  Mod_DpRx_MstHandler();
              #endif
1306   1      }
1307          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2901    ----
   CONSTANT SIZE    =    512    ----
   XDATA SIZE       =     49      86
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
