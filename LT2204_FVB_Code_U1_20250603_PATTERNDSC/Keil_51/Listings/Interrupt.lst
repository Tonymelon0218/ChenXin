C51 COMPILER V9.60.0.0   INTERRUPT                                                         11/21/2025 11:03:13 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE INTERRUPT
OBJECT MODULE PLACED IN .\Objects\Interrupt.obj
COMPILER INVOKED BY: D:\DevTools\Keil_5\Keil_v5\C51\BIN\C51.EXE ..\User\L1_Module\Interrupt.c LARGE OBJECTADVANCED OPTIM
                    -IZE(11,SIZE) REGFILE(.\Objects\LT6911GXD_Pattern_MIPI_C-PHY_2D_NoBurst_2160x2160@120_251121_01.ORC) BROWSE INCDIR(..\Use
                    -r\L0_App;..\User\L1_Module;..\User\L2_Drive;..\User\L3_Ocm) DEBUG PRINT(.\Listings\Interrupt.lst) OBJECT(.\Objects\Inter
                    -rupt.obj)

line level    source

   1          //////////////////////////////////////
   2          //Project:   LT2101
   3          //Filename:  Interrupt.c
   4          //Version:   V1.0
   5          //Copyright: Lontium
   6          //////////////////////////////////////
   7          #include "Include.h"
   8          
   9          void Mod_IT0_InterruptService(void) interrupt 0
  10          {
  11   1          #if RX_PORT_SIGN == DP_PORT
  12   1          if(Drv_System_IntFlagGet(IRQ_DPRX_AUX_INT))//aux rx_int flag
  13   1          {
  14   2              Drv_System_IntClr(IRQ_DPRX_AUX_INT);
  15   2              Mod_DpRx_AuxTask();
  16   2              Drv_DpRx_AcAuxTermCtrl(ENABLED);
  17   2          }
  18   1          #endif
  19   1          #if RX_PORT_SIGN == HDMI_PORT
                  #if HDMIRX_MAX_FRL_RATE != FRL_NOT_SPT
                  if(BKE5_41_REG & BIT4_1)//Hrx21_int
                  {
                      BKE5_31_REG |= BIT4_1;//[5]hdmi21 rx int clr en
                      BKE5_31_REG &= BIT4_0;//[5]hdmi21 rx int clr dis
                      Mod_FrlRx_FrlTask();
                  }
                  #endif
                  #endif
  29   1          
  30   1      }
  31          
  32          void Mod_IT1_InterruptService(void) interrupt 2
  33          {
  34   1              #if BB_EN == ENABLED
                      if((BKE5_10_REG & BIT6_1)==0x00)
                      {
                              if(BKE5_40_REG & BIT6_1)//BB intr
                              {    
                                      //printLT(PRINT_PRIO_HIG, "\nBB = 0x%02bx,0x%02bx,0x%02bx",BKC5_21_REG,BKC5_22_REG,BKC5_23_REG);
                                      BKE5_30_REG |= BIT6_1;//[5]clear bb_ininterrupt en
                                      BKE5_30_REG &= BIT6_0;//[5]clear bb_ininterrupt dis
                                      Drv_BB_Interrupt();
                              }
                      }
                  #endif
  46   1          #if ((CHIP_SEL == LT8711GXE)||(CHIP_SEL == LT7911UXE_DP)||(CHIP_SEL == LT6911GXD_DP)||(CHIP_SEL == LT6
             -711GXE))
  47   1          #if TYPECRX_EN == ENABLED
                  if(Drv_System_IntFlagGet(IRQ_CC1_INT))  //CC1 int
                  {
                      Drv_System_IntClr(IRQ_CC1_INT);
                      Mod_CC1Pd_Interrupt();
C51 COMPILER V9.60.0.0   INTERRUPT                                                         11/21/2025 11:03:13 PAGE 2   

                  }
                  if(Drv_System_IntFlagGet(IRQ_CC2_INT))  //CC2 int
                  {
                      Drv_System_IntClr(IRQ_CC2_INT);
                      #if TYPECTX_EN == ENABLED
                      Mod_CC2Pd_Interrupt();
                      #endif
                  }
                  #endif
  61   1          #endif
  62   1      
  63   1          
  64   1      }
  65          
  66          void Mod_IT2_InterruptService(void) interrupt 8 /////
  67          {    
  68   1          EXIF = 0x00;//soft clear the ex2
  69   1      }
  70          
  71          void Mod_Time2_InterruptService(void) interrupt 5// 0.25us per count,can be set by register
  72          {
  73   1          TF2 = 0;
  74   1          TR2 = 0;
  75   1          #if ((CHIP_SEL == LT8711GXE)||(CHIP_SEL == LT7911UXE_DP)||(CHIP_SEL == LT6911GXD_DP)||(CHIP_SEL == LT6
             -711GXE))
  76   1      //    #if DPRX_CDR_MODE != ANACDR
  77   1      //    while((g_stAuxStatus.ucTps_Pattern >= TPS1) && (g_stAuxStatus.usDelayCnt < 0x4E20)) //to fix cdr loo
             -p unlock issue.
  78   1      //    {
  79   1      //        DRV_DpRxCdr_FreqMonitor(g_stAuxStatus.ucLink_Count);
  80   1      //        g_stAuxStatus.usDelayCnt++;
  81   1      //    }
  82   1      //    #endif
  83   1          
  84   1          #if TYPECRX_EN == ENABLED
                  if(UCCStatus.b1PsRdy_Send== TRUE)//PS_RDY send
                  {
                      #if TYPECTX_EN == ENABLED
                      Mod_CC1PsRdy_Send();
                      #endif
                  }
                  else //Message resend
                  {      
                      Mod_CC1MsgSend_Retry();
                      #if TYPECTX_EN == ENABLED
                      Mod_CC2MsgSend_Retry();
                      #endif
                  }
                  #endif
  99   1          #endif
 100   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    102    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   INTERRUPT                                                         11/21/2025 11:03:13 PAGE 3   

   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
