C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:03:13 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MODMIPITX
OBJECT MODULE PLACED IN .\Objects\ModMipiTx.obj
COMPILER INVOKED BY: D:\DevTools\Keil_5\Keil_v5\C51\BIN\C51.EXE ..\User\L1_Module\ModMipiTx.c LARGE OBJECTADVANCED OPTIM
                    -IZE(11,SIZE) REGFILE(.\Objects\LT6911GXD_Pattern_MIPI_C-PHY_2D_NoBurst_2160x2160@120_251121_01.ORC) BROWSE INCDIR(..\Use
                    -r\L0_App;..\User\L1_Module;..\User\L2_Drive;..\User\L3_Ocm) DEBUG PRINT(.\Listings\ModMipiTx.lst) OBJECT(.\Objects\ModMi
                    -piTx.obj)

line level    source

   1          /******************************************************************************
   2            * @project: LT2204
   3            * @file: ChipMipi.c
   4            * @author: wtt
   5            * @company: LONTIUM
   6            * @date: 2022.05.26
   7          /******************************************************************************/
   8          #include "include.h"
   9          
  10          #if TX_PORT_SIGN == MIPI_PORT
  11          
  12          StructMipiTx g_stMipiTx;
  13          StructTiming g_stMipiTxVideoTiming;
  14          
  15          u8 code szMipiEdid[512] = {
  16              0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 0xB3, 0xA0, 0x28, 0x01, 0x01, 0x01, 0x01,
  17              0x04, 0x1F, 0x01, 0x03, 0x80, 0x3E, 0x22, 0x78, 0xEE, 0x69, 0x95, 0xAD, 0x52, 0x46, 0xA1, 0x27,
  18              0x0F, 0x50, 0x54, 0xBF, 0xCF, 0x00, 0x81, 0x40, 0x81, 0x80, 0x95, 0x00, 0x71, 0x4F, 0x81, 0xC0,
  19              0xB3, 0x00, 0xD1, 0xC0, 0x01, 0x01, 0x08, 0xE8, 0x00, 0x30, 0xF2, 0x70, 0x5A, 0x80, 0xB0, 0x58,
  20              0x8A, 0x00, 0x55, 0x50, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x18, 0x90, 0x1E,
  21              0xFF, 0x8A, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x56,
  22              0x47, 0x32, 0x38, 0x55, 0x51, 0x4C, 0x31, 0x41, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFF,
  23              0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x32, 0x38, 0x0A, 0x01, 0xF0,
  24              0x02, 0x03, 0x5A, 0xF1, 0x50, 0x04, 0x13, 0x1F, 0x10, 0x0F, 0x1E, 0x01, 0x5D, 0x5E, 0x5F, 0x60,
  25              0x61, 0x76, 0x03, 0x12, 0x3F, 0x23, 0x09, 0x07, 0x07, 0x83, 0x01, 0x00, 0x00, 0xE2, 0x00, 0xEA,
  26              0x6D, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x38, 0x3C, 0x28, 0x00, 0x60, 0x01, 0x02, 0x03, 0x6D, 0xD8,
  27              0x5D, 0xC4, 0x01, 0x78, 0x88, 0x53, 0x12, 0x30, 0x78, 0x83, 0x34, 0x1D, 0x6D, 0x1A, 0x00, 0x00,
  28              0x02, 0x01, 0x30, 0x90, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x05, 0xC0, 0x00, 0xE4, 0x21,
  29              0x00, 0x1C, 0x00, 0xE6, 0x06, 0x05, 0x01, 0x60, 0x60, 0x12, 0x36, 0x6C, 0x80, 0xA0, 0x70, 0x70,
  30              0x3E, 0x80, 0x30, 0x20, 0x08, 0x0C, 0x6D, 0x55, 0x21, 0x00, 0x00, 0x1A, 0x6F, 0xC2, 0x00, 0xA0,
  31              0xA0, 0xA0, 0x55, 0x50, 0x30, 0x20, 0x35, 0x00, 0x6D, 0x55, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x27};
  32          
  33          u8 szEdidData[512];
  34          
  35          StructMipiVideoFmtCfg g_MipiVideoFmtCfg[] =
  36              {
  37          #if MIPITX_PRO_SEL == MIPITX_DSI
  38                  {DSI_RGB_565, 16, 0x00, 0x0E, MIPITX_DSI},
  39                  {DSI_RGB_666, 18, 0x10, 0x1E, MIPITX_DSI},
  40                  {DSI_RGB_888, 24, 0x21, 0x3E, MIPITX_DSI}, // ÈªòËÆ§DSI
  41                  {DSI_RGB_30, 30, 0x41, 0x0D, MIPITX_DSI},
  42                  {DSI_YUV422_16Bit, 16, 0x01, 0x2C, MIPITX_DSI},
  43                  {DSI_YUV422_20Bit, 24, 0x24, 0x0C, MIPITX_DSI}, // ÊåâÁÖß24bitÂèëÈÄÅ 422 20 spec
  44                  {DSI_YUV422_24Bit, 24, 0x23, 0x1C, MIPITX_DSI},
  45                  {DSI_YUV420_12Bit, 24, 0x20, 0x3D, MIPITX_DSI}, // TODO:
  46          #else
                      {CSI_RGB_565, 16, 0x02, 0x22, MIPITX_CSI},
                      {CSI_RGB_666, 18, 0x11, 0x23, MIPITX_CSI},
                      {CSI_RGB_888, 24, 0x25, 0x24, MIPITX_CSI},
                      {CSI_YUV422_8Bit, 16, 0x01, 0x1E, MIPITX_CSI}, // ÈªòËÆ§CSI
                      {CSI_YUV422_10Bit, 20, 0x31, 0x1F, MIPITX_CSI},
                      {CSI_YUV420_8Bit, 24, 0x20, 0x1A, MIPITX_CSI}
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:03:13 PAGE 2   

              #endif
  54          };
  55          
  56          void Mod_MipiTx_PowerOnInit(void)
  57          {
  58   1          memset(&g_stMipiTx, 0, sizeof(StructMipiTx));
  59   1          g_stMipiTx.ucTxState = STATE_MIPITX_POWER_ON_1;
  60   1      
  61   1      #if (MIPITX_PRO_SEL == MIPITX_CSI)
                  Drv_MipiTx_CSIFeSoftwareSendInit();
              #endif
  64   1      }
  65          
  66          void Mod_MipiTx_SetState(u8 ucState)
  67          {
  68   1          if (ucState != g_stMipiTx.ucTxState)
  69   1          {
  70   2      #if (MIPITX_PRO_SEL == MIPITX_CSI)
              #if (1 == CSI_SOFTWARE_SEND_FE)
                      if (STATE_MIPITX_PLAY_BACK_8 == g_stMipiTx.ucTxState))
                          {
                              Drv_MipiTx_CSIFeSoftwareSend();
                              LTLog(LOG_INFO, "CSI Software Send Frame End");
                          }
              #endif
              #endif
  79   2      
  80   2              if (ucState == STATE_MIPITX_VIDEO_OUT_5)
  81   2              {
  82   3                  TX_Event_Set(TX_VIDEO_ON_EVENT_3);
  83   3              }
  84   2              g_stMipiTx.ucTxStateChangeFlag = TRUE;
  85   2              g_stMipiTx.ucTxState = ucState;
  86   2              LTLog(LOG_DEBUG, "TxState = 0x%02bx", ucState);
  87   2          }
  88   1      }
  89          
  90          // TODO: Â§ñÁïåÂÅö‰∏Ä‰∏™Êé•Âè£ÔºåÂØπÂÜÖÂè™Ê∂âÂèäRX Ôºàun)plug„ÄÅvideo on/off,‰∏çÁî®ÁªÜÂàÜÊòØdp ËøòÊòØhdmi
  91          /*
  92          0 : Source unplug 1:source plug
  93          2: video  OFF     3:video ON
  94          */
  95          void Mod_LMTx_EventMonitor(u8 ucMsgType)
  96          {
  97   1      #define SOURECE_PLUG_EVENT 1
  98   1      #define SOURECE_UNPLUG_EVENT 2
  99   1      #define VIDEO_ON_EVENT 3
 100   1      #define VIDEO_OFF_EVENT 4
 101   1      
 102   1          switch (ucMsgType)
 103   1          {
 104   2          case SOURECE_UNPLUG_EVENT: // HDMIRX_SOURECE_UNPLUG_EVENT  DPRX_SOURECE_UNPLUG_EVENT:
 105   2              g_stMipiTx.b1UpstreamDeviceReady = FALSE;
 106   2              LTLog(LOG_INFO, "RX Set Event:%02bx ", ucMsgType);
 107   2              break;
 108   2          case SOURECE_PLUG_EVENT: // HDMIRX_SOURECE_PLUG_EVENT DPRX_SOURECE_PLUG_EVENT
 109   2              g_stMipiTx.b1UpstreamDeviceReady = TRUE;
 110   2              LTLog(LOG_INFO, "RX Set Event:%02bx ", ucMsgType);
 111   2              break;
 112   2          case VIDEO_OFF_EVENT: // HDMIRX_VIDEO_OFF_EVENT DPRX_VIDEO_OFF_EVENT
 113   2              g_stMipiTx.b1UpstreamVideoReady = FALSE;
 114   2              LTLog(LOG_INFO, "RX Set Event:%02bx ", ucMsgType);
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:03:13 PAGE 3   

 115   2              break;
 116   2          case VIDEO_ON_EVENT: // HDMIRX_VIDEO_ON_EVENT DPRX_VIDEO_ON_EVENT
 117   2              g_stMipiTx.b1UpstreamVideoReady = TRUE;
 118   2              LTLog(LOG_INFO, "RX Set Event:%02bx ", ucMsgType);
 119   2              break;
 120   2          default:
 121   2              break;
 122   2          }
 123   1      }
 124          
 125          u8 Mod_MipiTx_VidEnCmd_Get(u8 IsCtrlEn, u8 UserReg)
 126          {
 127   1          if (IsCtrlEn == ENABLED)
 128   1          {
 129   2              if (UserReg != 0)
 130   2              {
 131   3                  return ON;
 132   3              }
 133   2              return OFF;
 134   2          }
 135   1          return ON;
 136   1      }
 137          
 138          void Mod_MipiTx_EventProc()
 139          {
 140   1          u8 ucMinState = 0xFF;
 141   1      
 142   1          if (g_stMipiTx.ucTxState > STATE_MIPITX_UPSTREAM_DEVICE_READY_2)
 143   1          {
 144   2              if (g_stMipiTx.b1UpstreamDeviceReady == FALSE)
 145   2              {
 146   3                  Mod_MipiTx_SetState(STATE_MIPITX_UPSTREAM_DEVICE_READY_2);
 147   3              }
 148   2          }
 149   1      
 150   1          if (g_stMipiTx.ucTxState > STATE_MIPITX_UPSTREAM_VIDEO_READY_3)
 151   1          {
 152   2              if (g_stMipiTx.b1UpstreamVideoReady == FALSE)
 153   2              {
 154   3                  Mod_MipiTx_SetState(STATE_MIPITX_UPSTREAM_VIDEO_READY_3);
 155   3              }
 156   2          }
 157   1      
 158   1          if (g_stMipiTx.ucTxState >= STATE_MIPITX_VIDEO_OUT_5)
 159   1          {
 160   2      #if MIPI_OUT_CTRL == ENABLED
                      if (Mod_MipiTx_VidEnCmd_Get(ENABLED, USER_VIDEOEN_REG) == OFF) // default off
              #else
 163   2              if (Mod_MipiTx_VidEnCmd_Get(DISABLED, USER_VIDEOEN_REG) == OFF) // default on
 164   2      #endif
 165   2              {
 166   3                  if (g_stMipiTx.b1MIPITXStreamOn == ON)
 167   3                  {
 168   4                      g_stMipiTx.b1MIPITXStreamOn = OFF;
 169   4                      Drv_MipiTx_Rst(DISABLED);
 170   4                      Drv_MipiTx_VideoSet(OFF);
 171   4                  }
 172   3              }
 173   2              else
 174   2              {
 175   3                  if (g_stMipiTx.b1MIPITXStreamOn == OFF)
 176   3                  {
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:03:13 PAGE 4   

 177   4                      ucMinState = min(ucMinState, STATE_MIPITX_VIDEO_OUT_5);
 178   4                      g_stMipiTx.b1MIPITXStreamOn = ON;
 179   4                  }
 180   3              }
 181   2          }
 182   1      
 183   1          if (ucMinState != 0xFF)
 184   1          {
 185   2              Mod_MipiTx_SetState(ucMinState);
 186   2          }
 187   1      }
 188          
 189          void Mod_MipiTx_PllSet()
 190          {
 191   1          u32 ulByteclk, ulPhyClk;
 192   1      
 193   1          ulPhyClk = g_stMipiTx.ulMipiDataRate;
 194   1          ulByteclk = ulPhyClk >> 3;
 195   1          LTLog(LOG_DEBUG, "MipiInClk:%ld, calc ulByteclk:%ld, ulPhyClk:%ld, ucBpp:%bd, ucTxPortNum:0x%02bx, ucT
             -xLaneNum:0x%02bx",
 196   1                g_stMipiTx.ulMipiInClk, ulByteclk, ulPhyClk, g_stMipiTx.ucBpp, g_stMipiTx.ucTxPortNum, g_stMipiT
             -x.ucTxLaneNum);
 197   1      
 198   1          Drv_MipiTx_PllSet(ulPhyClk);
 199   1      }
 200          
 201          u8 Mod_MipiTx_PllCaliIfSucc()
 202          {
 203   1          return Drv_MipiTx_PllCali();
 204   1      }
 205          
 206          void Mod_MipiTx_PhyTimingSet()
 207          {
 208   1          u32 ulMipiDataRate = g_stMipiTx.ulMipiDataRate;
 209   1          u8 b1MipiClockburst = g_stMipiTx.b1MipiClockburst;
 210   1          u8 ucPhySel = g_stMipiTx.ucTxPhySel;
 211   1          u8 ucDphyCsi8Lane = g_stMipiTx.b1DphyCsi8Lane;
 212   1          Drv_MipiTx_PhyTimingParaSet(ulMipiDataRate, b1MipiClockburst, ucPhySel, ucDphyCsi8Lane);
 213   1      }
 214          
 215          u8 Mod_MipiTx_BppCalculate(u8 ucMIPIDataFmt)
 216          {
 217   1          u8 ucBpp = 24;
 218   1          u8 ucIndex = 0;
 219   1          for (ucIndex = 0; ucIndex < sizeof(g_MipiVideoFmtCfg) / sizeof(g_MipiVideoFmtCfg[0]); ucIndex++)
 220   1          {
 221   2              if (ucMIPIDataFmt == g_MipiVideoFmtCfg[ucIndex].ucVideoFmt)
 222   2              {
 223   3                  ucBpp = g_MipiVideoFmtCfg[ucIndex].ucBpp;
 224   3                  break;
 225   3              }
 226   2          }
 227   1      
 228   1          return ucBpp;
 229   1      }
 230          
 231          void Mod_MipiTx_PortLaneAdj()
 232          {
 233   1      #if MIPITX_PRO_SEL == MIPITX_CSI
                  if (MIPITX_DPHY == g_stMipiTx.ucTxPhySel)
                  {
                      if (g_stMipiTx.ulMipiInClk > 600000) // over 4K60
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:03:13 PAGE 5   

                      {
                          g_stMipiTx.ucTxPortNum = MIPI_2PORT; // TODO: ÈªòËÆ§ÊòØCSI 8lane1901 Â¶ÇÊûúË∂ÖËøá600m
                          g_stMipiTx.ucTxLaneNum = MIPI_PORT_4LANE;
                      }
                      //        else
                      //        {
                      //            g_stMipiTx.ucTxPortNum = MIPI_1PORT;
                      //            g_stMipiTx.ucTxLaneNum = MIPI_PORT_4LANE;
                      //        }
                  }
              #endif
 248   1      
 249   1          if (MIPITX_CPHY == g_stMipiTx.ucTxPhySel)
 250   1          {
 251   2              if (g_stMipiTx.ucTxLaneNum > MIPI_PORT_3LANE) // for cphy , up to 3lane
 252   2              {
 253   3                  g_stMipiTx.ucTxLaneNum = MIPI_PORT_3LANE;
 254   3              }
 255   2          }
 256   1      }
 257          
 258          void Mod_MipiTx_CfgParaInit()
 259          {
 260   1          u32 ulMipiInClk;
 261   1          g_stMipiTx.ucTxLaneNum = MIPI_LANE_NUM;
 262   1          g_stMipiTx.b1MipiClockburst = MIPI_CLOCK_BURST;
 263   1          g_stMipiTx.b1DSIVideoMode = MIPI_DSI_VIDEO_MODE;
 264   1          g_stMipiTx.ucTxPhySel = MIPITX_PHY_SEL;
 265   1          g_stMipiTx.ucTxFormat = MIPITX_VIDEO_FORMAT;
 266   1      
 267   1      #if RX_PORT_SIGN == DP_PORT
 268   1      #if CUSTOM_EDID_SWITCH == ENABLED
              
              #else
 271   1          g_stMipiTx.ucTxPortNum = MIPI_PORT_NUM;
 272   1          g_stMipiTx.uc3DMode = MIPITX_3D_MODE_SEL;
 273   1      #endif
 274   1      #endif
 275   1      
 276   1      #if RX_PORT_SIGN == HDMI_PORT
                  g_stMipiTx.ucTxPortNum = MIPI_PORT_NUM;
                  g_stMipiTx.uc3DMode = MIPITX_3D_MODE_SEL;
              #endif
 280   1      
 281   1          g_stMipiTx.ucBpp = Mod_MipiTx_BppCalculate(g_stMipiTx.ucTxFormat);
 282   1          g_stMipiTx.b1MIPITXStreamOn = OFF;
 283   1      
 284   1          g_stMipiTx.b1MIPITXProSel = MIPITX_PRO_SEL;
 285   1          // Get input BPP
 286   1          ulMipiInClk = Drv_MipiTx_GetMipiInClk();
 287   1          if (0 != ulMipiInClk)
 288   1          {
 289   2              g_stMipiTx.ulMipiInClk = ulMipiInClk;
 290   2          }
 291   1          // adjust port or lane
 292   1          Mod_MipiTx_PortLaneAdj();
 293   1      }
 294          void Mod_MipiTx_DataRateAdj()
 295          {
 296   1          if (MIPITX_DPHY == g_stMipiTx.ucTxPhySel)
 297   1          {
 298   2              g_stMipiTx.ulMipiDataRate = g_stMipiTx.ulMipiInClk * 2 * g_stMipiTx.ucBpp / (g_stMipiTx.ucTxPortNu
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:03:13 PAGE 6   

             -m * g_stMipiTx.ucTxLaneNum);
 299   2          }
 300   1          else
 301   1          {
 302   2              g_stMipiTx.ulMipiDataRate = g_stMipiTx.ulMipiInClk * 2 * g_stMipiTx.ucBpp * 7 / (16 * g_stMipiTx.u
             -cTxPortNum * g_stMipiTx.ucTxLaneNum);
 303   2          }
 304   1      
 305   1          if (MIPI_NO_3D_MODE != g_stMipiTx.uc3DMode) // ref 1901
 306   1          {
 307   2              g_stMipiTx.ulMipiDataRate += 115000;
 308   2          }
 309   1          else
 310   1          {
 311   2              g_stMipiTx.ulMipiDataRate += 80000;
 312   2          }
 313   1      
 314   1          if (g_stMipiTx.b1MipiClockburst) // ref 2102
 315   1          {
 316   2              g_stMipiTx.ulMipiDataRate += 80000;
 317   2              LTLog(LOG_INFO, "Burst Mode lane rate increase 80M");
 318   2          }
 319   1      
 320   1          if (g_stMipiTx.ulMipiDataRate < MIPITX_PLL_LOW) // set byteclk minium value to 50M , phyclk minium val
             -ue is 400M
 321   1          {
 322   2              g_stMipiTx.ulMipiDataRate = MIPITX_PLL_LOW;
 323   2          }
 324   1          if (g_stMipiTx.ulMipiDataRate > MIPITX_PLL_HIGH) // set byteclk maxmum value to 312.5M , phyclk maxmum
             - value is 2.5G
 325   1          {
 326   2              g_stMipiTx.ulMipiDataRate = MIPITX_PLL_HIGH;
 327   2          }
 328   1      }
 329          
 330          void Mod_MipiTx_SetDataType(u8 ucVideoFormat)
 331          {
 332   1      #if MIPITX_PRO_SEL == MIPITX_DSI
 333   1          u8 ucDataType = 0x3E;
 334   1          u8 ucBppAndFmtSel = 0x21; // rgb 888
 335   1      #else
                  u8 ucDataType = 0x1E;
                  u8 ucBppAndFmtSel = 0x01; // CSI 422 8bit
              #endif
 339   1          u8 ucIndex = 0;
 340   1      
 341   1      #if MIPITX_DSC != ENABLED
                  for (ucIndex = 0; ucIndex < sizeof(g_MipiVideoFmtCfg) / sizeof(g_MipiVideoFmtCfg[0]); ucIndex++)
                  {
                      if (ucVideoFormat == g_MipiVideoFmtCfg[ucIndex].ucVideoFmt)
                      {
                          ucDataType = g_MipiVideoFmtCfg[ucIndex].ucDatatype;
                          ucBppAndFmtSel = g_MipiVideoFmtCfg[ucIndex].ucBppAndFmtsel;
                          break;
                      }
                  }
              #else
 352   1          // todo:
 353   1          ucDataType = 0x0B;
 354   1          ucBppAndFmtSel = 0x25;
 355   1      #endif
 356   1      
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:03:13 PAGE 7   

 357   1      #if RX_PORT_SIGN == DP_PORT
 358   1      #if (DPRX_DSC_BYPASS_SUPPORT == ENABLED)
                  if (Drv_DpRxDscBy_SwitchGet() == ENABLED)
                  {
                      ucDataType = 0x0B;
                      ucBppAndFmtSel = 0x25;
                  }
              #endif
 365   1      #endif
 366   1      
 367   1      #if RX_PORT_SIGN == HDMI_PORT
              #if (HDMIRX_DSC_BYPASS_SUPPORT == ENABLED)
                  if (Drv_HdmiRxDscBy_SwitchGet() == ENABLED)
                  {
                      ucDataType = 0x0B;
                      ucBppAndFmtSel = 0x25;
                  }
              #endif
              #endif
 376   1      
 377   1          Drv_MipiTx_DataTypeSet(ucDataType, ucBppAndFmtSel);
 378   1      }
*** WARNING C280 IN LINE 330 OF ..\User\L1_Module\ModMipiTx.c: 'ucVideoFormat': unreferenced local variable
 379          
 380          void Mod_MipiTx_Resolution_Config()
 381          {
 382   1          // Ëé∑Âèñtiming‰ø°ÊÅØ
 383   1          memset(&g_stMipiTxVideoTiming, 0, sizeof(StructTiming));
 384   1          Drv_VideoCheckAll_Get(&g_stMipiTxVideoTiming);
 385   1          LTLog(LOG_INFO, "RX[H]: Htotal:%d,Hactive:%d,Hsw:%d,Hfp:%d,Hbp:%d,Hspol:%bd", g_stMipiTxVideoTiming.Ht
             -otal, g_stMipiTxVideoTiming.Hactive, g_stMipiTxVideoTiming.Hsw, g_stMipiTxVideoTiming.Hfp, g_stMipiTxVideoTiming.Hbp, g_
             -stMipiTxVideoTiming.Hspol);
 386   1          LTLog(LOG_INFO, "RX[V]: Vtotal:%d,Vactive:%d,Vsw:%d,Vfp:%d,Vbp:%d,Vspol:%bd", g_stMipiTxVideoTiming.Vt
             -otal, g_stMipiTxVideoTiming.Vactive, g_stMipiTxVideoTiming.Vsw, g_stMipiTxVideoTiming.Vfp, g_stMipiTxVideoTiming.Vbp, g_
             -stMipiTxVideoTiming.Vspol);
 387   1          // ËÆæÁΩÆmipi timing‰ø°ÊÅØ
 388   1          Drv_MipiTx_TimingSet(&g_stMipiTxVideoTiming);
 389   1      
 390   1          // ÊûÅÊÄßËé∑Âèñ
 391   1          Drv_MipiTx_InHSyncPol_Sel(g_stMipiTxVideoTiming.Hspol);
 392   1          Drv_MipiTx_InVSyncPol_Sel(g_stMipiTxVideoTiming.Vspol);
 393   1      }
 394          
 395          void Mod_MipiTx_Digital_Config()
 396          {
 397   1          Drv_MipiTx_Rst(ENABLED);
 398   1          Drv_MipiTx_LaneSwap(); // if need adjust lane,please modify
 399   1          Drv_MipiTx_PortSwap(g_stMipiTx.ucTxPortNum);
 400   1          Drv_MipiTx_PortNumSet(g_stMipiTx.ucTxPortNum);
 401   1          Drv_MipiTx_LaneNumSet(g_stMipiTx.ucTxLaneNum);
 402   1          LTLog(LOG_INFO, "Port: %02bx, Lane: %02bx", g_stMipiTx.ucTxPortNum, g_stMipiTx.ucTxLaneNum);
 403   1      #if MIPITX_PHY_SEL == MIPITX_CPHY
 404   1          Drv_MipiTx_CPhyEn(ENABLED);
 405   1          LTLog(LOG_INFO, "select Mipi Cphy");
 406   1          // TODO: ËøôÈáåÊ≤°Êúâclk ÂèØ‰ª•ÈÄâÊã©ÔºåÊï∞Â≠óÂíåÊ®°ÊãüÈÉΩÊú™Êèê‰æõÔºå‰∏çÂΩ±ÂìçDphy‰ª•ÂèäÈùû8lane Dphy
             - CSI
 407   1          SET_BIT(BKA3_7B_REG, BIT2);
 408   1      #else
                  Drv_MipiTx_DPhyClkDataSet();
                  Drv_MipiTx_DPhyClkModeSet(g_stMipiTx.b1MipiClockburst);
              #if MIPITX_PRO_SEL == MIPITX_DSI
                  Drv_MipiTx_DSIVideoModeSet(g_stMipiTx.b1DSIVideoMode);
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:03:13 PAGE 8   

              #endif
                  CLEAR_BIT(BKA3_7B_REG, BIT2);
                  if (g_stMipiTx.b1DphyCsi8Lane)
                  {
                      // TODO: DPHY CSI 8Lane Êó†Ê≥ïÈÄâÊã©write clk
                      SET_BIT(BKA3_7B_REG, BIT2);
                      Drv_MipiTx_DPhyCSI8LaneEn(ENABLED);
                  }
                  Drv_MipiTx_EotpSet(ENABLED);
              
              #endif
 424   1          Drv_MipiTx_PhyModeSet(g_stMipiTx.ucTxPhySel);
 425   1          Drv_MipiTx_LmtxModeSet(g_stMipiTx.ucTxPhySel);
 426   1          Drv_MipiTx_LmtxSrcSet();
 427   1          Drv_MipiTx_LmtxInputDataSet();
 428   1          Drv_MipiTx_LmtxSramInputSet();
 429   1          // TODO: 0xF97A bit 4 - MIPI protocol vactive select:HW or SW?
 430   1      #if (MIPITX_PRO_SEL == MIPITX_CSI)
                  // ÂºÄÂêØ CSI frame number enable.
                  Drv_MipiTx_FrameCntSet(ON);
              #else
 434   1          Drv_MipiTx_HssLP_En(MIPITX_HSS_BURST_EN);
 435   1          Drv_MipiTx_FrameCntSet(OFF);
 436   1      #endif
 437   1      
 438   1          Drv_MipiTx_3DModeSet(g_stMipiTx.uc3DMode);
 439   1      
 440   1          Mod_MipiTx_SetDataType(g_stMipiTx.ucTxFormat);
 441   1      
 442   1      #if RX_PORT_SIGN == DP_PORT
 443   1      #if (DPRX_DSC_BYPASS_SUPPORT == ENABLED)
                  if (Drv_DpRxDscBy_SwitchGet() == ENABLED)
                  {
                      LTLog(LOG_INFO, "DSC soft wordcnt;");
                      Drv_MipiTx_WordCnt_Set(SW_MODE, g_stDpRxDscByTiming.usHact / g_stMipiTx.ucTxPortNum, g_stMipiTx.uc
             -TxPortNum);
                      Drv_MipiTx_Dsc_Split(g_stMipiTxVideoTiming.Hactive, g_stMipiTx.ucTxPortNum);
                  }
              #endif
 451   1      #endif
 452   1      
 453   1      #if MIPITX_DSC == ENABLED
 454   1          LTLog(LOG_INFO, "DSC soft wordcnt;");
 455   1          Drv_MipiTx_WordCnt_Set(SW_MODE, g_stMipiTxDscEncVideoTiming.Hactive / g_stMipiTx.ucTxPortNum, g_stMipi
             -Tx.ucTxPortNum);
 456   1          Drv_MipiTx_Dsc_Split(g_stMipiTxVideoTiming.Hactive, g_stMipiTx.ucTxPortNum);
 457   1      #endif
 458   1      }
 459          
 460          void Mod_MipiTx_Anolog_Config()
 461          {
 462   1          Drv_MipiTx_PhySet(MP0_EN, MP1_EN, MP2_EN, MP3_EN);
 463   1      }
 464          
 465          void Mod_MipiTx_HssSet()
 466          {
 467   1          u16 Hss = 0x0A;
 468   1      #if (MIPITX_PRO_SEL == MIPITX_CSI)
                  if (MIPITX_DPHY == g_stMipiTx.ucTxPhySel)
                  {
                      if (g_stMipiTx.b1MipiClockburst == ENABLED)
                      {
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:03:13 PAGE 9   

                          Hss = (3 * Drv_mipiTx_GetHsRqstPre() + Drv_MipiTx_GetHsTrail() + 9) / 2 + 20;
                      }
                      else
                      {
                          Hss = (Drv_mipiTx_GetHsRqstPre() + (Drv_MipiTx_GetHsTrail() + 13) / 2) + 20;
                      }
                  }
              #else
 481   1          if (MIPITX_CPHY == g_stMipiTx.ucTxPhySel)
 482   1          {
 483   2              if (3 != g_stMipiTx.ucTxLaneNum)
 484   2              {
 485   3                  Hss = 0x20;
 486   3              }
 487   2          }
 488   1      #if MIPITX_HSCMD_EN == ENABLED
                  {
                      Hss = MIPITX_HSCMD_HSSLEN;
                  }
              #endif
 493   1      #endif
 494   1      
 495   1          Drv_MipiTx_Hss_Set(Hss);
 496   1      }
 497          
 498          void Mod_MipiTx_FifoRddly_Config()
 499          {
 500   1          u16 rdpixclk, rdbyteclk, rdhss, rgodhact;
 501   1          u32 rddly, rddly_max, rddly_min1, rddly_min2;
 502   1          u32 Temp;
 503   1      
 504   1          rdpixclk = (u16)(g_stMipiTx.ulMipiInClk / 1000);
 505   1          rdbyteclk = (u16)(g_stMipiTx.ulMipiDataRate / 2000);
 506   1          if (MIPITX_DPHY == g_stMipiTx.ucTxPhySel)
 507   1          {
 508   2              rdbyteclk /= 8;
 509   2          }
 510   1          else
 511   1          {
 512   2              rdbyteclk /= 7;
 513   2          }
 514   1      
 515   1          if ((ENABLED == g_stMipiTx.b1DphyCsi8Lane) || (MIPITX_CPHY == g_stMipiTx.ucTxPhySel))
 516   1          {
 517   2              rdbyteclk <<= 1;
 518   2          }
 519   1          rdbyteclk *= g_stMipiTx.ucTxPortNum;
 520   1          rdhss = Drv_MipiTx_Hss_Get();
 521   1          rgodhact = Drv_MipiTx_FSMHact_Get();
 522   1      
 523   1          LTLog(LOG_DEBUG, "rdbyteclk:%d, rdpixclk:%d ", rdbyteclk, rdpixclk);
 524   1          LTLog(LOG_DEBUG, "hsw:%d, hbp:%d hactive:%d", g_stMipiTxVideoTiming.Hsw, g_stMipiTxVideoTiming.Hbp, g_
             -stMipiTxVideoTiming.Hactive);
 525   1      
 526   1          Temp = (rdbyteclk * (g_stMipiTxVideoTiming.Hsw / 2 + g_stMipiTxVideoTiming.Hbp / 2) / rdpixclk);
 527   1          if (Temp > rdhss)
 528   1          {
 529   2              rddly_min1 = (rdbyteclk * (g_stMipiTxVideoTiming.Hsw / 2 + g_stMipiTxVideoTiming.Hbp / 2) / rdpixc
             -lk) - rdhss;
 530   2          }
 531   1          else
 532   1          {
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:03:13 PAGE 10  

 533   2              rddly_min1 = 0;
 534   2          }
 535   1      
 536   1          if (1 == g_stMipiTx.ucTxPortNum)
 537   1          {
 538   2              rddly_min2 = (u32)rdbyteclk * (g_stMipiTxVideoTiming.Hsw / 2 + g_stMipiTxVideoTiming.Hbp / 2 + g_s
             -tMipiTxVideoTiming.Hactive / 2);
 539   2              Temp = ((u32)rddly_min2 / (u32)rdpixclk);
 540   2              if (Temp > (rdhss + rgodhact))
 541   2              {
 542   3                  rddly_min2 = (u32)(((u32)rddly_min2 / (u32)rdpixclk) - rdhss - rgodhact);
 543   3              }
 544   2              else
 545   2              {
 546   3                  rddly_min2 = 0;
 547   3              }
 548   2          }
 549   1          else
 550   1          {
 551   2              rddly_min2 = rddly_min1;
 552   2          }
 553   1      
 554   1          if (rddly_min1 > rddly_min2)
 555   1          {
 556   2              rddly_min2 = rddly_min1;
 557   2          }
 558   1      
 559   1          LTLog(LOG_DEBUG, "ucBpp 0x%02bx;", g_stMipiTx.ucBpp);
 560   1      
 561   1          rddly_max = 0x8000 / (g_stMipiTx.ucBpp << 1);
 562   1          rddly_max = rdbyteclk * (rddly_max + g_stMipiTxVideoTiming.Hsw / 2 + g_stMipiTxVideoTiming.Hbp / 2);
 563   1          rddly_max = rddly_max / (u32)rdpixclk - rdhss;
 564   1          // rddly = (rddly_max - rddly_min2) / 20 + rddly_min2;
 565   1          rddly = (rddly_max / 7) + rddly_min2;
 566   1      
 567   1          if (2 == g_stMipiTx.ucTxPortNum && g_stMipiTxVideoTiming.Hbp > 1000) // 720P 25Hz hbp=2268 ‰ª•‰∏äÂÖ¨Âº
             -è‰∏çÂèØÁî®
 568   1          {
 569   2              rddly = rddly_max / 7 + rddly_min2 / 2;
 570   2          }
 571   1      
 572   1          LTLog(LOG_INFO, "read delay:%lu", rddly);
 573   1      
 574   1          Drv_MipiTx_FifoDelay_Set(rddly);
 575   1      }
 576          
 577          void Mod_MipiTx_ByteClk_Chk(void)
 578          {
 579   1          u32 TempClock = 0;
 580   1      
 581   1          Drv_System_FmSet(TOP_FM, 0x31);
 582   1          Ocm_Delay1ms(5);
 583   1          TempClock = Drv_System_FmGet(TOP_FM, 0);
 584   1          LTLog(LOG_INFO, "Ad_lmtx_write_clk = %lukhz", TempClock);
 585   1      
 586   1          Drv_System_FmSet(TOP_FM, 0x30);
 587   1          Ocm_Delay1ms(5);
 588   1          TempClock = Drv_System_FmGet(TOP_FM, 0);
 589   1          LTLog(LOG_INFO, "Ad_lmtx_read_clk = %lukhz", TempClock);
 590   1      }
 591          
 592          void Mod_MipiTx_StateHandler()
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:03:13 PAGE 11  

 593          {
 594   1          switch (g_stMipiTx.ucTxState)
 595   1          {
 596   2          case STATE_MIPITX_POWER_ON_1:
 597   2              Mod_MipiTx_SetState(STATE_MIPITX_UPSTREAM_DEVICE_READY_2);
 598   2              break;
 599   2      
 600   2          case STATE_MIPITX_UPSTREAM_DEVICE_READY_2:
 601   2              if (g_stMipiTx.ucTxStateChangeFlag)
 602   2              {
 603   3                  g_stMipiTx.ucTxStateChangeFlag = FALSE;
 604   3                  Drv_MipiTx_VideoSet(OFF);
 605   3                  Drv_GPIO19Vsync_Set(DISABLED);
 606   3      #if ((CHIP_SEL == LT6911GXD_HD) || (CHIP_SEL == LT7911UXE_HD))
                          g_stHdmiRx.b1DownstreamDeviceReady = TRUE;
              #if EDID_FLASH == ENABLED
                          {
                              Custom_EDID_LoadFromFlash();
                          }
              #else
                          memcpy(szEdidData, szMipiEdid, 512);
              #endif
              #endif
 616   3      
 617   3      #if ((CHIP_SEL == LT7911UXE_DP) || (CHIP_SEL == LT6911GXD_DP))
 618   3                  g_stDpRx.b1DownstreamDeviceReady = TRUE;
 619   3      #if EDID_FLASH == ENABLED
                          {
                              Custom_EDID_LoadFromFlash();
                          }
              #else
 624   3      #if CUSTOM_EDID_SWITCH == ENABLED
              
              #else
 627   3                  memcpy(szEdidData, szMipiEdid, 512);
 628   3      #endif
 629   3      #endif
 630   3      #endif
 631   3              }
 632   2      
 633   2              if (g_stMipiTx.b1UpstreamDeviceReady)
 634   2              {
 635   3                  Mod_MipiTx_SetState(STATE_MIPITX_UPSTREAM_VIDEO_READY_3);
 636   3              }
 637   2              break;
 638   2          case STATE_MIPITX_UPSTREAM_VIDEO_READY_3:
 639   2              if (g_stMipiTx.ucTxStateChangeFlag)
 640   2              {
 641   3                  g_stMipiTx.ucTxStateChangeFlag = FALSE;
 642   3                  Drv_MipiTx_VideoSet(OFF);
 643   3                  Drv_GPIO19Vsync_Set(DISABLED);
 644   3              }
 645   2      
 646   2              if (g_stMipiTx.b1UpstreamVideoReady)
 647   2              {
 648   3                  Mod_MipiTx_SetState(STATE_MIPITX_CONFIG_VIDEO_AUDIO_4);
 649   3      #if MIPITX_DSC == ENABLED
 650   3                  Drv_Sys_EncPowerDomain(FALSE);
 651   3                  // Drv_Gpio_ModeSet(GPIO6_D2, OUT_PP_2x | NO_PU_PD, VOL_3_3);//led ÈÄÇÈÖçÈ£ûÁ∫ø
 652   3                  Mod_MipiTxDscEnc_Config();
 653   3                  Ocm_Delay1ms(20);
 654   3      #endif
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:03:13 PAGE 12  

 655   3      
 656   3                  Drv_Sys_DHTxPowerDomain(FALSE);
 657   3              }
 658   2              break;
 659   2      
 660   2          case STATE_MIPITX_CONFIG_VIDEO_AUDIO_4:
 661   2              Mod_MipiTx_CfgParaInit();
 662   2              Mod_MipiTx_DataRateAdj();
 663   2              Mod_MipiTx_PllSet();
 664   2      
 665   2              if (!Mod_MipiTx_PllCaliIfSucc())
 666   2              {
 667   3                  return;
 668   3              }
 669   2              Mod_MipiTx_Resolution_Config();
 670   2              Mod_MipiTx_PhyTimingSet();
 671   2              Mod_MipiTx_Digital_Config(); // TODO:
 672   2              Mod_MipiTx_Anolog_Config();  // TODO:
 673   2      
 674   2              Mod_MipiTx_HssSet();
 675   2              Mod_MipiTx_FifoRddly_Config();
 676   2              Mod_MipiTx_ByteClk_Chk();
 677   2      
 678   2              Mod_MipiTx_SetState(STATE_MIPITX_VIDEO_OUT_5);
 679   2              break;
 680   2          case STATE_MIPITX_VIDEO_OUT_5:
 681   2              if (g_stMipiTx.b1MIPITXStreamOn == ON)
 682   2              {
 683   3                  Drv_MipiTx_Rst(ENABLED);
 684   3      #if (MIPITX_PRO_SEL == MIPITX_DSI)
 685   3                  // 25090302: GPIO Control
 686   3                  Drv_Gpio_ModeSet(GPIO12_D1_VDET, OUT_PP_2x | NO_PU_PD, VOL_1_8);
 687   3                  Drv_IOSoftLevel_Set(GPIO12_D1_VDET, HIGH); // GPIO12 1.8V‰æõÁîµ
 688   3                  Ocm_Delay1ms(50);
 689   3      
 690   3                  Drv_Gpio_ModeSet(GPIO0_EARCN, OUT_PP_2x | NO_PU_PD, VOL_3_3);
 691   3                  Drv_IOSoftLevel_Set(GPIO0_EARCN, HIGH); // GPIO0 Ê≠£Ë¥üÁîµÂéã
 692   3                  Ocm_Delay1ms(50);
 693   3      
 694   3                  Drv_Gpio_ModeSet(GPIO15_D2_VDET, OUT_PP_2x | NO_PU_PD, VOL_3_3);
 695   3                  Drv_IOSoftLevel_Set(GPIO15_D2_VDET, HIGH); // GPIO15 Â§ç‰Ωç
 696   3                  Ocm_Delay1ms(5);
 697   3                  Drv_Gpio_ModeSet(GPIO1_EARCP, OUT_PP_2x | NO_PU_PD, VOL_3_3);
 698   3                  Drv_IOSoftLevel_Set(GPIO1_EARCP, HIGH); // GPIO1 Â§ç‰Ωç
 699   3                  Ocm_Delay1ms(200);
 700   3      
 701   3                  Mod_DCS_Init(); // ‰∏ãÂèëÂ±èÂèÇÊåá‰ª§
 702   3                  Ocm_Delay1ms(200);
 703   3      
 704   3                  Drv_Gpio_ModeSet(GPIO3_DHRX_DCAUXP, OUT_PP_2x | NO_PU_PD, VOL_3_3);
 705   3                  Drv_IOSoftLevel_Set(GPIO3_DHRX_DCAUXP, HIGH); // GPIO3 ËÉåÂÖâ
 706   3                  Ocm_Delay1ms(50);
 707   3      
 708   3                  Drv_Gpio_ModeSet(GPIO24_PWM2, OUT_PP_2x | NO_PU_PD, VOL_3_3);
 709   3                  Drv_IOSoftLevel_Set(GPIO24_PWM2, HIGH); // GPIO24 PWM
 710   3                  Ocm_Delay1ms(50);
 711   3      
 712   3      #endif
 713   3      
 714   3                  if (MIPITX_DPHY == g_stMipiTx.ucTxPhySel)
 715   3                  {
 716   4                      Drv_MipiTx_DPhyClkHsTrig();
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:03:13 PAGE 13  

 717   4                      Drv_MipiTx_DPhySkewCali();
 718   4                  }
 719   3      
 720   3                  Drv_MipiTx_VideoSet(ON);
 721   3                  Mod_MipiTx_SetState(STATE_MIPITX_AUDIO_OUT_6);
 722   3              }
 723   2              break;
 724   2          case STATE_MIPITX_AUDIO_OUT_6:
 725   2              Drv_Audio_Init();
 726   2      #if TDM_SUPPORT == ENABLED
                      Drv_Audio_TdmOutInit();
              #endif
 729   2              Mod_MipiTx_SetState(STATE_MIPITX_PLAY_BACK_7);
 730   2              break;
 731   2          case STATE_MIPITX_PLAY_BACK_7:
 732   2              break;
 733   2          default:
 734   2              break;
 735   2          }
 736   1      }
 737          
 738          void Mod_MipiTx_Handler(void)
 739          {
 740   1          Mod_MipiTx_StateHandler();
 741   1          Mod_MipiTx_EventProc();
 742   1      }
 743          
 744          void Mod_MIPITx_Pattern(void)
 745          {
 746   1      #if MIPITX_VID_PATTERN_MODE != NO_PATTERN
 747   1          ModPattern_Init();
 748   1          g_stMipiTx.b1UpstreamVideoReady = TRUE;
 749   1          g_stMipiTx.b1UpstreamDeviceReady = TRUE;
 750   1      
 751   1      #if CSC_SUPPORT == ENABLED
              
              #if ((CHIP_SEL == LT6911GXD_HD) || (CHIP_SEL == LT7911UXE_HD))
                  LT6911GXE_HdmiRxCscOrEncSel();
                  LT6911GXE_HdmiRxCscCvt();
              #endif
              
              #if ((CHIP_SEL == LT7911UXE_DP) || (CHIP_SEL == LT6911GXD_DP))
                  LT7911GXE_DpRxCscOrEncSel();
                  LT7911GXE_DpRxCscCvt();
              #endif
              
              #endif
 764   1          while (1)
 765   1          {
 766   2              Mod_MipiTx_Handler();
 767   2          }
 768   1      #endif
 769   1      }
 770          
 771          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3115    ----
   CONSTANT SIZE    =    999    ----
   XDATA SIZE       =    609      53
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:03:13 PAGE 14  

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
