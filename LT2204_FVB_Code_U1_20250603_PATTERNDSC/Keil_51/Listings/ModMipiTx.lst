C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:48:29 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MODMIPITX
OBJECT MODULE PLACED IN .\Objects\ModMipiTx.obj
COMPILER INVOKED BY: D:\DevTools\Keil_5\Keil_v5\C51\BIN\C51.EXE ..\User\L1_Module\ModMipiTx.c LARGE OBJECTADVANCED OPTIM
                    -IZE(11,SIZE) REGFILE(.\Objects\LT6911GXD_Pattern_MIPI_C-PHY_2D_NoBurst_2160x2160@120_251121_03.ORC) BROWSE INCDIR(..\Use
                    -r\L0_App;..\User\L1_Module;..\User\L2_Drive;..\User\L3_Ocm) DEBUG PRINT(.\Listings\ModMipiTx.lst) OBJECT(.\Objects\ModMi
                    -piTx.obj)

line level    source

   1          /******************************************************************************
   2            * @project: LT2204
   3            * @file: ChipMipi.c
   4            * @author: wtt
   5            * @company: LONTIUM
   6            * @date: 2022.05.26
   7          /******************************************************************************/
   8          #include "include.h"
   9          
  10          #if TX_PORT_SIGN == MIPI_PORT
  11          
  12          StructMipiTx g_stMipiTx;
  13          StructTiming g_stMipiTxVideoTiming;
  14          
  15          u8 code szMipiEdid[512] = {
  16              0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 0xB3, 0xA0, 0x28, 0x01, 0x01, 0x01, 0x01,
  17              0x04, 0x1F, 0x01, 0x03, 0x80, 0x3E, 0x22, 0x78, 0xEE, 0x69, 0x95, 0xAD, 0x52, 0x46, 0xA1, 0x27,
  18              0x0F, 0x50, 0x54, 0xBF, 0xCF, 0x00, 0x81, 0x40, 0x81, 0x80, 0x95, 0x00, 0x71, 0x4F, 0x81, 0xC0,
  19              0xB3, 0x00, 0xD1, 0xC0, 0x01, 0x01, 0x08, 0xE8, 0x00, 0x30, 0xF2, 0x70, 0x5A, 0x80, 0xB0, 0x58,
  20              0x8A, 0x00, 0x55, 0x50, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x18, 0x90, 0x1E,
  21              0xFF, 0x8A, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x56,
  22              0x47, 0x32, 0x38, 0x55, 0x51, 0x4C, 0x31, 0x41, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFF,
  23              0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x32, 0x38, 0x0A, 0x01, 0xF0,
  24              0x02, 0x03, 0x5A, 0xF1, 0x50, 0x04, 0x13, 0x1F, 0x10, 0x0F, 0x1E, 0x01, 0x5D, 0x5E, 0x5F, 0x60,
  25              0x61, 0x76, 0x03, 0x12, 0x3F, 0x23, 0x09, 0x07, 0x07, 0x83, 0x01, 0x00, 0x00, 0xE2, 0x00, 0xEA,
  26              0x6D, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x38, 0x3C, 0x28, 0x00, 0x60, 0x01, 0x02, 0x03, 0x6D, 0xD8,
  27              0x5D, 0xC4, 0x01, 0x78, 0x88, 0x53, 0x12, 0x30, 0x78, 0x83, 0x34, 0x1D, 0x6D, 0x1A, 0x00, 0x00,
  28              0x02, 0x01, 0x30, 0x90, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x05, 0xC0, 0x00, 0xE4, 0x21,
  29              0x00, 0x1C, 0x00, 0xE6, 0x06, 0x05, 0x01, 0x60, 0x60, 0x12, 0x36, 0x6C, 0x80, 0xA0, 0x70, 0x70,
  30              0x3E, 0x80, 0x30, 0x20, 0x08, 0x0C, 0x6D, 0x55, 0x21, 0x00, 0x00, 0x1A, 0x6F, 0xC2, 0x00, 0xA0,
  31              0xA0, 0xA0, 0x55, 0x50, 0x30, 0x20, 0x35, 0x00, 0x6D, 0x55, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x27};
  32          
  33          u8 szEdidData[512];
  34          
  35          StructMipiVideoFmtCfg g_MipiVideoFmtCfg[] =
  36              {
  37          #if MIPITX_PRO_SEL == MIPITX_DSI
  38                  {DSI_RGB_565, 16, 0x00, 0x0E, MIPITX_DSI},
  39                  {DSI_RGB_666, 18, 0x10, 0x1E, MIPITX_DSI},
  40                  {DSI_RGB_888, 24, 0x21, 0x3E, MIPITX_DSI}, // ÈªòËÆ§DSI
  41                  {DSI_RGB_30, 30, 0x41, 0x0D, MIPITX_DSI},
  42                  {DSI_YUV422_16Bit, 16, 0x01, 0x2C, MIPITX_DSI},
  43                  {DSI_YUV422_20Bit, 24, 0x24, 0x0C, MIPITX_DSI}, // ÊåâÁÖß24bitÂèëÈÄÅ 422 20 spec
  44                  {DSI_YUV422_24Bit, 24, 0x23, 0x1C, MIPITX_DSI},
  45                  {DSI_YUV420_12Bit, 24, 0x20, 0x3D, MIPITX_DSI}, // TODO:
  46          #else
                      {CSI_RGB_565, 16, 0x02, 0x22, MIPITX_CSI},
                      {CSI_RGB_666, 18, 0x11, 0x23, MIPITX_CSI},
                      {CSI_RGB_888, 24, 0x25, 0x24, MIPITX_CSI},
                      {CSI_YUV422_8Bit, 16, 0x01, 0x1E, MIPITX_CSI}, // ÈªòËÆ§CSI
                      {CSI_YUV422_10Bit, 20, 0x31, 0x1F, MIPITX_CSI},
                      {CSI_YUV420_8Bit, 24, 0x20, 0x1A, MIPITX_CSI}
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:48:29 PAGE 2   

              #endif
  54          };
  55          
  56          void Mod_MipiTx_PowerOnInit(void)
  57          {
  58   1          memset(&g_stMipiTx, 0, sizeof(StructMipiTx));
  59   1          g_stMipiTx.ucTxState = STATE_MIPITX_POWER_ON_1;
  60   1      
  61   1      #if (MIPITX_PRO_SEL == MIPITX_CSI)
                  Drv_MipiTx_CSIFeSoftwareSendInit();
              #endif
  64   1      }
  65          
  66          void Mod_MipiTx_SetState(u8 ucState)
  67          {
  68   1          if (ucState != g_stMipiTx.ucTxState)
  69   1          {
  70   2      #if (MIPITX_PRO_SEL == MIPITX_CSI)
              #if (1 == CSI_SOFTWARE_SEND_FE)
                      if (STATE_MIPITX_PLAY_BACK_8 == g_stMipiTx.ucTxState))
                          {
                              Drv_MipiTx_CSIFeSoftwareSend();
                              LTLog(LOG_INFO, "CSI Software Send Frame End");
                          }
              #endif
              #endif
  79   2      
  80   2              if (ucState == STATE_MIPITX_VIDEO_OUT_5)
  81   2              {
  82   3                  TX_Event_Set(TX_VIDEO_ON_EVENT_3);
  83   3              }
  84   2              g_stMipiTx.ucTxStateChangeFlag = TRUE;
  85   2              g_stMipiTx.ucTxState = ucState;
  86   2              LTLog(LOG_DEBUG, "TxState = 0x%02bx", ucState);
  87   2          }
  88   1      }
  89          
  90          // TODO: Â§ñÁïåÂÅö‰∏Ä‰∏™Êé•Âè£ÔºåÂØπÂÜÖÂè™Ê∂âÂèäRX Ôºàun)plug„ÄÅvideo on/off,‰∏çÁî®ÁªÜÂàÜÊòØdp ËøòÊòØhdmi
  91          /*
  92          0 : Source unplug 1:source plug
  93          2: video  OFF     3:video ON
  94          */
  95          void Mod_LMTx_EventMonitor(u8 ucMsgType)
  96          {
  97   1      #define SOURECE_PLUG_EVENT 1
  98   1      #define SOURECE_UNPLUG_EVENT 2
  99   1      #define VIDEO_ON_EVENT 3
 100   1      #define VIDEO_OFF_EVENT 4
 101   1      
 102   1          switch (ucMsgType)
 103   1          {
 104   2          case SOURECE_UNPLUG_EVENT: // HDMIRX_SOURECE_UNPLUG_EVENT  DPRX_SOURECE_UNPLUG_EVENT:
 105   2              g_stMipiTx.b1UpstreamDeviceReady = FALSE;
 106   2              LTLog(LOG_INFO, "RX Set Event:%02bx ", ucMsgType);
 107   2              break;
 108   2          case SOURECE_PLUG_EVENT: // HDMIRX_SOURECE_PLUG_EVENT DPRX_SOURECE_PLUG_EVENT
 109   2              g_stMipiTx.b1UpstreamDeviceReady = TRUE;
 110   2              LTLog(LOG_INFO, "RX Set Event:%02bx ", ucMsgType);
 111   2              break;
 112   2          case VIDEO_OFF_EVENT: // HDMIRX_VIDEO_OFF_EVENT DPRX_VIDEO_OFF_EVENT
 113   2              g_stMipiTx.b1UpstreamVideoReady = FALSE;
 114   2              LTLog(LOG_INFO, "RX Set Event:%02bx ", ucMsgType);
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:48:29 PAGE 3   

 115   2              break;
 116   2          case VIDEO_ON_EVENT: // HDMIRX_VIDEO_ON_EVENT DPRX_VIDEO_ON_EVENT
 117   2              g_stMipiTx.b1UpstreamVideoReady = TRUE;
 118   2              LTLog(LOG_INFO, "RX Set Event:%02bx ", ucMsgType);
 119   2              break;
 120   2          default:
 121   2              break;
 122   2          }
 123   1      }
 124          
 125          u8 Mod_MipiTx_VidEnCmd_Get(u8 IsCtrlEn, u8 UserReg)
 126          {
 127   1          if (IsCtrlEn == ENABLED)
 128   1          {
 129   2              if (UserReg != 0)
 130   2              {
 131   3                  return ON;
 132   3              }
 133   2              return OFF;
 134   2          }
 135   1          return ON;
 136   1      }
 137          
 138          void Mod_MipiTx_EventProc()
 139          {
 140   1          u8 ucMinState = 0xFF;
 141   1      
 142   1          if (g_stMipiTx.ucTxState > STATE_MIPITX_UPSTREAM_DEVICE_READY_2)
 143   1          {
 144   2              if (g_stMipiTx.b1UpstreamDeviceReady == FALSE)
 145   2              {
 146   3                  Mod_MipiTx_SetState(STATE_MIPITX_UPSTREAM_DEVICE_READY_2);
 147   3              }
 148   2          }
 149   1      
 150   1          if (g_stMipiTx.ucTxState > STATE_MIPITX_UPSTREAM_VIDEO_READY_3)
 151   1          {
 152   2              if (g_stMipiTx.b1UpstreamVideoReady == FALSE)
 153   2              {
 154   3                  Mod_MipiTx_SetState(STATE_MIPITX_UPSTREAM_VIDEO_READY_3);
 155   3              }
 156   2          }
 157   1      
 158   1          if (g_stMipiTx.ucTxState >= STATE_MIPITX_VIDEO_OUT_5)
 159   1          {
 160   2      #if MIPI_OUT_CTRL == ENABLED
                      if (Mod_MipiTx_VidEnCmd_Get(ENABLED, USER_VIDEOEN_REG) == OFF) // default off
              #else
 163   2              if (Mod_MipiTx_VidEnCmd_Get(DISABLED, USER_VIDEOEN_REG) == OFF) // default on
 164   2      #endif
 165   2              {
 166   3                  if (g_stMipiTx.b1MIPITXStreamOn == ON)
 167   3                  {
 168   4                      g_stMipiTx.b1MIPITXStreamOn = OFF;
 169   4                      Drv_MipiTx_Rst(DISABLED);
 170   4                      Drv_MipiTx_VideoSet(OFF);
 171   4                  }
 172   3              }
 173   2              else
 174   2              {
 175   3                  if (g_stMipiTx.b1MIPITXStreamOn == OFF)
 176   3                  {
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:48:29 PAGE 4   

 177   4                      ucMinState = min(ucMinState, STATE_MIPITX_VIDEO_OUT_5);
 178   4                      g_stMipiTx.b1MIPITXStreamOn = ON;
 179   4                  }
 180   3              }
 181   2          }
 182   1      
 183   1          if (ucMinState != 0xFF)
 184   1          {
 185   2              Mod_MipiTx_SetState(ucMinState);
 186   2          }
 187   1      }
 188          
 189          void Mod_MipiTx_PllSet()
 190          {
 191   1          u32 ulByteclk, ulPhyClk;
 192   1      
 193   1          ulPhyClk = g_stMipiTx.ulMipiDataRate;
 194   1          ulByteclk = ulPhyClk >> 3;
 195   1          LTLog(LOG_DEBUG, "MipiInClk:%ld, calc ulByteclk:%ld, ulPhyClk:%ld, ucBpp:%bd, ucTxPortNum:0x%02bx, ucT
             -xLaneNum:0x%02bx",
 196   1                g_stMipiTx.ulMipiInClk, ulByteclk, ulPhyClk, g_stMipiTx.ucBpp, g_stMipiTx.ucTxPortNum, g_stMipiT
             -x.ucTxLaneNum);
 197   1      
 198   1          Drv_MipiTx_PllSet(ulPhyClk);
 199   1      }
 200          
 201          u8 Mod_MipiTx_PllCaliIfSucc()
 202          {
 203   1          return Drv_MipiTx_PllCali();
 204   1      }
 205          
 206          void Mod_MipiTx_PhyTimingSet()
 207          {
 208   1          u32 ulMipiDataRate = g_stMipiTx.ulMipiDataRate;
 209   1          u8 b1MipiClockburst = g_stMipiTx.b1MipiClockburst;
 210   1          u8 ucPhySel = g_stMipiTx.ucTxPhySel;
 211   1          u8 ucDphyCsi8Lane = g_stMipiTx.b1DphyCsi8Lane;
 212   1          Drv_MipiTx_PhyTimingParaSet(ulMipiDataRate, b1MipiClockburst, ucPhySel, ucDphyCsi8Lane);
 213   1      }
 214          
 215          u8 Mod_MipiTx_BppCalculate(u8 ucMIPIDataFmt)
 216          {
 217   1          u8 ucBpp = 24;
 218   1          u8 ucIndex = 0;
 219   1          for (ucIndex = 0; ucIndex < sizeof(g_MipiVideoFmtCfg) / sizeof(g_MipiVideoFmtCfg[0]); ucIndex++)
 220   1          {
 221   2              if (ucMIPIDataFmt == g_MipiVideoFmtCfg[ucIndex].ucVideoFmt)
 222   2              {
 223   3                  ucBpp = g_MipiVideoFmtCfg[ucIndex].ucBpp;
 224   3                  break;
 225   3              }
 226   2          }
 227   1      
 228   1          return ucBpp;
 229   1      }
 230          
 231          void Mod_MipiTx_PortLaneAdj()
 232          {
 233   1      #if MIPITX_PRO_SEL == MIPITX_CSI
                  if (MIPITX_DPHY == g_stMipiTx.ucTxPhySel)
                  {
                      if (g_stMipiTx.ulMipiInClk > 600000) // over 4K60
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:48:29 PAGE 5   

                      {
                          g_stMipiTx.ucTxPortNum = MIPI_2PORT; // TODO: ÈªòËÆ§ÊòØCSI 8lane1901 Â¶ÇÊûúË∂ÖËøá600m
                          g_stMipiTx.ucTxLaneNum = MIPI_PORT_4LANE;
                      }
                      //        else
                      //        {
                      //            g_stMipiTx.ucTxPortNum = MIPI_1PORT;
                      //            g_stMipiTx.ucTxLaneNum = MIPI_PORT_4LANE;
                      //        }
                  }
              #endif
 248   1      
 249   1          if (MIPITX_CPHY == g_stMipiTx.ucTxPhySel)
 250   1          {
 251   2              if (g_stMipiTx.ucTxLaneNum > MIPI_PORT_3LANE) // for cphy , up to 3lane
 252   2              {
 253   3                  g_stMipiTx.ucTxLaneNum = MIPI_PORT_3LANE;
 254   3              }
 255   2          }
 256   1      }
 257          
 258          void Mod_MipiTx_CfgParaInit()
 259          {
 260   1          u32 ulMipiInClk;
 261   1          g_stMipiTx.ucTxLaneNum = MIPI_LANE_NUM;
 262   1          g_stMipiTx.b1MipiClockburst = MIPI_CLOCK_BURST;
 263   1          g_stMipiTx.b1DSIVideoMode = MIPI_DSI_VIDEO_MODE;
 264   1          g_stMipiTx.ucTxPhySel = MIPITX_PHY_SEL;
 265   1          g_stMipiTx.ucTxFormat = MIPITX_VIDEO_FORMAT;
 266   1      
 267   1      #if RX_PORT_SIGN == DP_PORT
 268   1      #if CUSTOM_EDID_SWITCH == ENABLED
              
              #else
 271   1          g_stMipiTx.ucTxPortNum = MIPI_PORT_NUM;
 272   1          g_stMipiTx.uc3DMode = MIPITX_3D_MODE_SEL;
 273   1      #endif
 274   1      #endif
 275   1      
 276   1      #if RX_PORT_SIGN == HDMI_PORT
                  g_stMipiTx.ucTxPortNum = MIPI_PORT_NUM;
                  g_stMipiTx.uc3DMode = MIPITX_3D_MODE_SEL;
              #endif
 280   1      
 281   1          g_stMipiTx.ucBpp = Mod_MipiTx_BppCalculate(g_stMipiTx.ucTxFormat);
 282   1          g_stMipiTx.b1MIPITXStreamOn = OFF;
 283   1      
 284   1          g_stMipiTx.b1MIPITXProSel = MIPITX_PRO_SEL;
 285   1          // Get input BPP
 286   1          ulMipiInClk = Drv_MipiTx_GetMipiInClk();
 287   1          if (0 != ulMipiInClk)
 288   1          {
 289   2              g_stMipiTx.ulMipiInClk = ulMipiInClk;
 290   2          }
 291   1          // adjust port or lane
 292   1          Mod_MipiTx_PortLaneAdj();
 293   1      }
 294          void Mod_MipiTx_DataRateAdj()
 295          {
 296   1          if (MIPITX_DPHY == g_stMipiTx.ucTxPhySel)
 297   1          {
 298   2              g_stMipiTx.ulMipiDataRate = g_stMipiTx.ulMipiInClk * 2 * g_stMipiTx.ucBpp / (g_stMipiTx.ucTxPortNu
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:48:29 PAGE 6   

             -m * g_stMipiTx.ucTxLaneNum);
 299   2          }
 300   1          else
 301   1          {
 302   2              g_stMipiTx.ulMipiDataRate = g_stMipiTx.ulMipiInClk * 2 * g_stMipiTx.ucBpp * 7 / (16 * g_stMipiTx.u
             -cTxPortNum * g_stMipiTx.ucTxLaneNum);
 303   2          }
 304   1      
 305   1          if (MIPI_NO_3D_MODE != g_stMipiTx.uc3DMode) // ref 1901
 306   1          {
 307   2              g_stMipiTx.ulMipiDataRate += 115000;
 308   2          }
 309   1          else
 310   1          {
 311   2              g_stMipiTx.ulMipiDataRate += 80000;
 312   2          }
 313   1      
 314   1          if (g_stMipiTx.b1MipiClockburst) // ref 2102
 315   1          {
 316   2              g_stMipiTx.ulMipiDataRate += 80000;
 317   2              LTLog(LOG_INFO, "Burst Mode lane rate increase 80M");
 318   2          }
 319   1      
 320   1          g_stMipiTx.ulMipiDataRate += 50000; // MIPI ÈÄüÁéáÂ¢ûÂä†50M
 321   1      
 322   1          if (g_stMipiTx.ulMipiDataRate < MIPITX_PLL_LOW) // set byteclk minium value to 50M , phyclk minium val
             -ue is 400M
 323   1          {
 324   2              g_stMipiTx.ulMipiDataRate = MIPITX_PLL_LOW;
 325   2          }
 326   1          if (g_stMipiTx.ulMipiDataRate > MIPITX_PLL_HIGH) // set byteclk maxmum value to 312.5M , phyclk maxmum
             - value is 2.5G
 327   1          {
 328   2              g_stMipiTx.ulMipiDataRate = MIPITX_PLL_HIGH;
 329   2          }
 330   1      }
 331          
 332          void Mod_MipiTx_SetDataType(u8 ucVideoFormat)
 333          {
 334   1      #if MIPITX_PRO_SEL == MIPITX_DSI
 335   1          u8 ucDataType = 0x3E;
 336   1          u8 ucBppAndFmtSel = 0x21; // rgb 888
 337   1      #else
                  u8 ucDataType = 0x1E;
                  u8 ucBppAndFmtSel = 0x01; // CSI 422 8bit
              #endif
 341   1          u8 ucIndex = 0;
 342   1      
 343   1      #if MIPITX_DSC != ENABLED
                  for (ucIndex = 0; ucIndex < sizeof(g_MipiVideoFmtCfg) / sizeof(g_MipiVideoFmtCfg[0]); ucIndex++)
                  {
                      if (ucVideoFormat == g_MipiVideoFmtCfg[ucIndex].ucVideoFmt)
                      {
                          ucDataType = g_MipiVideoFmtCfg[ucIndex].ucDatatype;
                          ucBppAndFmtSel = g_MipiVideoFmtCfg[ucIndex].ucBppAndFmtsel;
                          break;
                      }
                  }
              #else
 354   1          // todo:
 355   1          ucDataType = 0x0B;
 356   1          ucBppAndFmtSel = 0x25;
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:48:29 PAGE 7   

 357   1      #endif
 358   1      
 359   1      #if RX_PORT_SIGN == DP_PORT
 360   1      #if (DPRX_DSC_BYPASS_SUPPORT == ENABLED)
                  if (Drv_DpRxDscBy_SwitchGet() == ENABLED)
                  {
                      ucDataType = 0x0B;
                      ucBppAndFmtSel = 0x25;
                  }
              #endif
 367   1      #endif
 368   1      
 369   1      #if RX_PORT_SIGN == HDMI_PORT
              #if (HDMIRX_DSC_BYPASS_SUPPORT == ENABLED)
                  if (Drv_HdmiRxDscBy_SwitchGet() == ENABLED)
                  {
                      ucDataType = 0x0B;
                      ucBppAndFmtSel = 0x25;
                  }
              #endif
              #endif
 378   1      
 379   1          Drv_MipiTx_DataTypeSet(ucDataType, ucBppAndFmtSel);
 380   1      }
*** WARNING C280 IN LINE 332 OF ..\User\L1_Module\ModMipiTx.c: 'ucVideoFormat': unreferenced local variable
 381          
 382          void Mod_MipiTx_Resolution_Config()
 383          {
 384   1          // Ëé∑Âèñtiming‰ø°ÊÅØ
 385   1          memset(&g_stMipiTxVideoTiming, 0, sizeof(StructTiming));
 386   1          Drv_VideoCheckAll_Get(&g_stMipiTxVideoTiming);
 387   1          LTLog(LOG_INFO, "RX[H]: Htotal:%d,Hactive:%d,Hsw:%d,Hfp:%d,Hbp:%d,Hspol:%bd", g_stMipiTxVideoTiming.Ht
             -otal, g_stMipiTxVideoTiming.Hactive, g_stMipiTxVideoTiming.Hsw, g_stMipiTxVideoTiming.Hfp, g_stMipiTxVideoTiming.Hbp, g_
             -stMipiTxVideoTiming.Hspol);
 388   1          LTLog(LOG_INFO, "RX[V]: Vtotal:%d,Vactive:%d,Vsw:%d,Vfp:%d,Vbp:%d,Vspol:%bd", g_stMipiTxVideoTiming.Vt
             -otal, g_stMipiTxVideoTiming.Vactive, g_stMipiTxVideoTiming.Vsw, g_stMipiTxVideoTiming.Vfp, g_stMipiTxVideoTiming.Vbp, g_
             -stMipiTxVideoTiming.Vspol);
 389   1          // ËÆæÁΩÆmipi timing‰ø°ÊÅØ
 390   1          Drv_MipiTx_TimingSet(&g_stMipiTxVideoTiming);
 391   1      
 392   1          // ÊûÅÊÄßËé∑Âèñ
 393   1          Drv_MipiTx_InHSyncPol_Sel(g_stMipiTxVideoTiming.Hspol);
 394   1          Drv_MipiTx_InVSyncPol_Sel(g_stMipiTxVideoTiming.Vspol);
 395   1      }
 396          
 397          void Mod_MipiTx_Digital_Config()
 398          {
 399   1          Drv_MipiTx_Rst(ENABLED);
 400   1          Drv_MipiTx_LaneSwap(); // if need adjust lane,please modify
 401   1          Drv_MipiTx_PortSwap(g_stMipiTx.ucTxPortNum);
 402   1          Drv_MipiTx_PortNumSet(g_stMipiTx.ucTxPortNum);
 403   1          Drv_MipiTx_LaneNumSet(g_stMipiTx.ucTxLaneNum);
 404   1          LTLog(LOG_INFO, "Port: %02bx, Lane: %02bx", g_stMipiTx.ucTxPortNum, g_stMipiTx.ucTxLaneNum);
 405   1      #if MIPITX_PHY_SEL == MIPITX_CPHY
 406   1          Drv_MipiTx_CPhyEn(ENABLED);
 407   1          LTLog(LOG_INFO, "select Mipi Cphy");
 408   1          // TODO: ËøôÈáåÊ≤°Êúâclk ÂèØ‰ª•ÈÄâÊã©ÔºåÊï∞Â≠óÂíåÊ®°ÊãüÈÉΩÊú™Êèê‰æõÔºå‰∏çÂΩ±ÂìçDphy‰ª•ÂèäÈùû8lane Dphy
             - CSI
 409   1          SET_BIT(BKA3_7B_REG, BIT2);
 410   1      #else
                  Drv_MipiTx_DPhyClkDataSet();
                  Drv_MipiTx_DPhyClkModeSet(g_stMipiTx.b1MipiClockburst);
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:48:29 PAGE 8   

              #if MIPITX_PRO_SEL == MIPITX_DSI
                  Drv_MipiTx_DSIVideoModeSet(g_stMipiTx.b1DSIVideoMode);
              #endif
                  CLEAR_BIT(BKA3_7B_REG, BIT2);
                  if (g_stMipiTx.b1DphyCsi8Lane)
                  {
                      // TODO: DPHY CSI 8Lane Êó†Ê≥ïÈÄâÊã©write clk
                      SET_BIT(BKA3_7B_REG, BIT2);
                      Drv_MipiTx_DPhyCSI8LaneEn(ENABLED);
                  }
                  Drv_MipiTx_EotpSet(ENABLED);
              
              #endif
 426   1          Drv_MipiTx_PhyModeSet(g_stMipiTx.ucTxPhySel);
 427   1          Drv_MipiTx_LmtxModeSet(g_stMipiTx.ucTxPhySel);
 428   1          Drv_MipiTx_LmtxSrcSet();
 429   1          Drv_MipiTx_LmtxInputDataSet();
 430   1          Drv_MipiTx_LmtxSramInputSet();
 431   1          // TODO: 0xF97A bit 4 - MIPI protocol vactive select:HW or SW?
 432   1      #if (MIPITX_PRO_SEL == MIPITX_CSI)
                  // ÂºÄÂêØ CSI frame number enable.
                  Drv_MipiTx_FrameCntSet(ON);
              #else
 436   1          Drv_MipiTx_HssLP_En(MIPITX_HSS_BURST_EN);
 437   1          Drv_MipiTx_FrameCntSet(OFF);
 438   1      #endif
 439   1      
 440   1          Drv_MipiTx_3DModeSet(g_stMipiTx.uc3DMode);
 441   1      
 442   1          Mod_MipiTx_SetDataType(g_stMipiTx.ucTxFormat);
 443   1      
 444   1      #if RX_PORT_SIGN == DP_PORT
 445   1      #if (DPRX_DSC_BYPASS_SUPPORT == ENABLED)
                  if (Drv_DpRxDscBy_SwitchGet() == ENABLED)
                  {
                      LTLog(LOG_INFO, "DSC soft wordcnt;");
                      Drv_MipiTx_WordCnt_Set(SW_MODE, g_stDpRxDscByTiming.usHact / g_stMipiTx.ucTxPortNum, g_stMipiTx.uc
             -TxPortNum);
                      Drv_MipiTx_Dsc_Split(g_stMipiTxVideoTiming.Hactive, g_stMipiTx.ucTxPortNum);
                  }
              #endif
 453   1      #endif
 454   1      
 455   1      #if MIPITX_DSC == ENABLED
 456   1          LTLog(LOG_INFO, "DSC soft wordcnt;");
 457   1          Drv_MipiTx_WordCnt_Set(SW_MODE, g_stMipiTxDscEncVideoTiming.Hactive / g_stMipiTx.ucTxPortNum, g_stMipi
             -Tx.ucTxPortNum);
 458   1          Drv_MipiTx_Dsc_Split(g_stMipiTxVideoTiming.Hactive, g_stMipiTx.ucTxPortNum);
 459   1      #endif
 460   1      }
 461          
 462          void Mod_MipiTx_Anolog_Config()
 463          {
 464   1          Drv_MipiTx_PhySet(MP0_EN, MP1_EN, MP2_EN, MP3_EN);
 465   1      }
 466          
 467          void Mod_MipiTx_HssSet()
 468          {
 469   1          u16 Hss = 0x0A;
 470   1      #if (MIPITX_PRO_SEL == MIPITX_CSI)
                  if (MIPITX_DPHY == g_stMipiTx.ucTxPhySel)
                  {
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:48:29 PAGE 9   

                      if (g_stMipiTx.b1MipiClockburst == ENABLED)
                      {
                          Hss = (3 * Drv_mipiTx_GetHsRqstPre() + Drv_MipiTx_GetHsTrail() + 9) / 2 + 20;
                      }
                      else
                      {
                          Hss = (Drv_mipiTx_GetHsRqstPre() + (Drv_MipiTx_GetHsTrail() + 13) / 2) + 20;
                      }
                  }
              #else
 483   1          if (MIPITX_CPHY == g_stMipiTx.ucTxPhySel)
 484   1          {
 485   2              if (3 != g_stMipiTx.ucTxLaneNum)
 486   2              {
 487   3                  Hss = 0x20;
 488   3              }
 489   2          }
 490   1      #if MIPITX_HSCMD_EN == ENABLED
                  {
                      Hss = MIPITX_HSCMD_HSSLEN;
                  }
              #endif
 495   1      #endif
 496   1      
 497   1          Drv_MipiTx_Hss_Set(Hss);
 498   1      }
 499          
 500          void Mod_MipiTx_FifoRddly_Config()
 501          {
 502   1          u16 rdpixclk, rdbyteclk, rdhss, rgodhact;
 503   1          u32 rddly, rddly_max, rddly_min1, rddly_min2;
 504   1          u32 Temp;
 505   1      
 506   1          rdpixclk = (u16)(g_stMipiTx.ulMipiInClk / 1000);
 507   1          rdbyteclk = (u16)(g_stMipiTx.ulMipiDataRate / 2000);
 508   1          if (MIPITX_DPHY == g_stMipiTx.ucTxPhySel)
 509   1          {
 510   2              rdbyteclk /= 8;
 511   2          }
 512   1          else
 513   1          {
 514   2              rdbyteclk /= 7;
 515   2          }
 516   1      
 517   1          if ((ENABLED == g_stMipiTx.b1DphyCsi8Lane) || (MIPITX_CPHY == g_stMipiTx.ucTxPhySel))
 518   1          {
 519   2              rdbyteclk <<= 1;
 520   2          }
 521   1          rdbyteclk *= g_stMipiTx.ucTxPortNum;
 522   1          rdhss = Drv_MipiTx_Hss_Get();
 523   1          rgodhact = Drv_MipiTx_FSMHact_Get();
 524   1      
 525   1          LTLog(LOG_DEBUG, "rdbyteclk:%d, rdpixclk:%d ", rdbyteclk, rdpixclk);
 526   1          LTLog(LOG_DEBUG, "hsw:%d, hbp:%d hactive:%d", g_stMipiTxVideoTiming.Hsw, g_stMipiTxVideoTiming.Hbp, g_
             -stMipiTxVideoTiming.Hactive);
 527   1      
 528   1          Temp = (rdbyteclk * (g_stMipiTxVideoTiming.Hsw / 2 + g_stMipiTxVideoTiming.Hbp / 2) / rdpixclk);
 529   1          if (Temp > rdhss)
 530   1          {
 531   2              rddly_min1 = (rdbyteclk * (g_stMipiTxVideoTiming.Hsw / 2 + g_stMipiTxVideoTiming.Hbp / 2) / rdpixc
             -lk) - rdhss;
 532   2          }
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:48:29 PAGE 10  

 533   1          else
 534   1          {
 535   2              rddly_min1 = 0;
 536   2          }
 537   1      
 538   1          if (1 == g_stMipiTx.ucTxPortNum)
 539   1          {
 540   2              rddly_min2 = (u32)rdbyteclk * (g_stMipiTxVideoTiming.Hsw / 2 + g_stMipiTxVideoTiming.Hbp / 2 + g_s
             -tMipiTxVideoTiming.Hactive / 2);
 541   2              Temp = ((u32)rddly_min2 / (u32)rdpixclk);
 542   2              if (Temp > (rdhss + rgodhact))
 543   2              {
 544   3                  rddly_min2 = (u32)(((u32)rddly_min2 / (u32)rdpixclk) - rdhss - rgodhact);
 545   3              }
 546   2              else
 547   2              {
 548   3                  rddly_min2 = 0;
 549   3              }
 550   2          }
 551   1          else
 552   1          {
 553   2              rddly_min2 = rddly_min1;
 554   2          }
 555   1      
 556   1          if (rddly_min1 > rddly_min2)
 557   1          {
 558   2              rddly_min2 = rddly_min1;
 559   2          }
 560   1      
 561   1          LTLog(LOG_DEBUG, "ucBpp 0x%02bx;", g_stMipiTx.ucBpp);
 562   1      
 563   1          rddly_max = 0x8000 / (g_stMipiTx.ucBpp << 1);
 564   1          rddly_max = rdbyteclk * (rddly_max + g_stMipiTxVideoTiming.Hsw / 2 + g_stMipiTxVideoTiming.Hbp / 2);
 565   1          rddly_max = rddly_max / (u32)rdpixclk - rdhss;
 566   1          // rddly = (rddly_max - rddly_min2) / 20 + rddly_min2;
 567   1          rddly = (rddly_max / 7) + rddly_min2;
 568   1      
 569   1          if (2 == g_stMipiTx.ucTxPortNum && g_stMipiTxVideoTiming.Hbp > 1000) // 720P 25Hz hbp=2268 ‰ª•‰∏äÂÖ¨Âº
             -è‰∏çÂèØÁî®
 570   1          {
 571   2              rddly = rddly_max / 7 + rddly_min2 / 2;
 572   2          }
 573   1      
 574   1          LTLog(LOG_INFO, "read delay:%lu", rddly);
 575   1      
 576   1          Drv_MipiTx_FifoDelay_Set(rddly);
 577   1      }
 578          
 579          void Mod_MipiTx_ByteClk_Chk(void)
 580          {
 581   1          u32 TempClock = 0;
 582   1      
 583   1          Drv_System_FmSet(TOP_FM, 0x31);
 584   1          Ocm_Delay1ms(5);
 585   1          TempClock = Drv_System_FmGet(TOP_FM, 0);
 586   1          LTLog(LOG_INFO, "Ad_lmtx_write_clk = %lukhz", TempClock);
 587   1      
 588   1          Drv_System_FmSet(TOP_FM, 0x30);
 589   1          Ocm_Delay1ms(5);
 590   1          TempClock = Drv_System_FmGet(TOP_FM, 0);
 591   1          LTLog(LOG_INFO, "Ad_lmtx_read_clk = %lukhz", TempClock);
 592   1      }
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:48:29 PAGE 11  

 593          
 594          void Mod_MipiTx_StateHandler()
 595          {
 596   1          switch (g_stMipiTx.ucTxState)
 597   1          {
 598   2          case STATE_MIPITX_POWER_ON_1:
 599   2              Mod_MipiTx_SetState(STATE_MIPITX_UPSTREAM_DEVICE_READY_2);
 600   2              break;
 601   2      
 602   2          case STATE_MIPITX_UPSTREAM_DEVICE_READY_2:
 603   2              if (g_stMipiTx.ucTxStateChangeFlag)
 604   2              {
 605   3                  g_stMipiTx.ucTxStateChangeFlag = FALSE;
 606   3                  Drv_MipiTx_VideoSet(OFF);
 607   3                  Drv_GPIO19Vsync_Set(DISABLED);
 608   3      #if ((CHIP_SEL == LT6911GXD_HD) || (CHIP_SEL == LT7911UXE_HD))
                          g_stHdmiRx.b1DownstreamDeviceReady = TRUE;
              #if EDID_FLASH == ENABLED
                          {
                              Custom_EDID_LoadFromFlash();
                          }
              #else
                          memcpy(szEdidData, szMipiEdid, 512);
              #endif
              #endif
 618   3      
 619   3      #if ((CHIP_SEL == LT7911UXE_DP) || (CHIP_SEL == LT6911GXD_DP))
 620   3                  g_stDpRx.b1DownstreamDeviceReady = TRUE;
 621   3      #if EDID_FLASH == ENABLED
                          {
                              Custom_EDID_LoadFromFlash();
                          }
              #else
 626   3      #if CUSTOM_EDID_SWITCH == ENABLED
              
              #else
 629   3                  memcpy(szEdidData, szMipiEdid, 512);
 630   3      #endif
 631   3      #endif
 632   3      #endif
 633   3              }
 634   2      
 635   2              if (g_stMipiTx.b1UpstreamDeviceReady)
 636   2              {
 637   3                  Mod_MipiTx_SetState(STATE_MIPITX_UPSTREAM_VIDEO_READY_3);
 638   3              }
 639   2              break;
 640   2          case STATE_MIPITX_UPSTREAM_VIDEO_READY_3:
 641   2              if (g_stMipiTx.ucTxStateChangeFlag)
 642   2              {
 643   3                  g_stMipiTx.ucTxStateChangeFlag = FALSE;
 644   3                  Drv_MipiTx_VideoSet(OFF);
 645   3                  Drv_GPIO19Vsync_Set(DISABLED);
 646   3              }
 647   2      
 648   2              if (g_stMipiTx.b1UpstreamVideoReady)
 649   2              {
 650   3                  Mod_MipiTx_SetState(STATE_MIPITX_CONFIG_VIDEO_AUDIO_4);
 651   3      #if MIPITX_DSC == ENABLED
 652   3                  Drv_Sys_EncPowerDomain(FALSE);
 653   3                  // Drv_Gpio_ModeSet(GPIO6_D2, OUT_PP_2x | NO_PU_PD, VOL_3_3);//led ÈÄÇÈÖçÈ£ûÁ∫ø
 654   3                  Mod_MipiTxDscEnc_Config();
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:48:29 PAGE 12  

 655   3                  Ocm_Delay1ms(20);
 656   3      #endif
 657   3      
 658   3                  Drv_Sys_DHTxPowerDomain(FALSE);
 659   3              }
 660   2              break;
 661   2      
 662   2          case STATE_MIPITX_CONFIG_VIDEO_AUDIO_4:
 663   2              Mod_MipiTx_CfgParaInit();
 664   2              Mod_MipiTx_DataRateAdj();
 665   2              Mod_MipiTx_PllSet();
 666   2      
 667   2              if (!Mod_MipiTx_PllCaliIfSucc())
 668   2              {
 669   3                  return;
 670   3              }
 671   2              Mod_MipiTx_Resolution_Config();
 672   2              Mod_MipiTx_PhyTimingSet();
 673   2              Mod_MipiTx_Digital_Config(); // TODO:
 674   2              Mod_MipiTx_Anolog_Config();  // TODO:
 675   2      
 676   2              Mod_MipiTx_HssSet();
 677   2              Mod_MipiTx_FifoRddly_Config();
 678   2              Mod_MipiTx_ByteClk_Chk();
 679   2      
 680   2              Mod_MipiTx_SetState(STATE_MIPITX_VIDEO_OUT_5);
 681   2              break;
 682   2          case STATE_MIPITX_VIDEO_OUT_5:
 683   2              if (g_stMipiTx.b1MIPITXStreamOn == ON)
 684   2              {
 685   3                  Drv_MipiTx_Rst(ENABLED);
 686   3      #if (MIPITX_PRO_SEL == MIPITX_DSI)
 687   3                  // 25090302: GPIO Control
 688   3                  Drv_Gpio_ModeSet(GPIO12_D1_VDET, OUT_PP_2x | NO_PU_PD, VOL_1_8);
 689   3                  Drv_IOSoftLevel_Set(GPIO12_D1_VDET, HIGH); // GPIO12 1.8V‰æõÁîµ
 690   3                  Ocm_Delay1ms(50);
 691   3      
 692   3                  Drv_Gpio_ModeSet(GPIO0_EARCN, OUT_PP_2x | NO_PU_PD, VOL_3_3);
 693   3                  Drv_IOSoftLevel_Set(GPIO0_EARCN, HIGH); // GPIO0 Ê≠£Ë¥üÁîµÂéã
 694   3                  Ocm_Delay1ms(50);
 695   3      
 696   3                  Drv_Gpio_ModeSet(GPIO15_D2_VDET, OUT_PP_2x | NO_PU_PD, VOL_3_3);
 697   3                  Drv_IOSoftLevel_Set(GPIO15_D2_VDET, HIGH); // GPIO15 Â§ç‰Ωç
 698   3                  Ocm_Delay1ms(5);
 699   3                  Drv_Gpio_ModeSet(GPIO1_EARCP, OUT_PP_2x | NO_PU_PD, VOL_3_3);
 700   3                  Drv_IOSoftLevel_Set(GPIO1_EARCP, HIGH); // GPIO1 Â§ç‰Ωç
 701   3                  Ocm_Delay1ms(200);
 702   3      
 703   3                  Mod_DCS_Init(); // ‰∏ãÂèëÂ±èÂèÇÊåá‰ª§
 704   3                  Ocm_Delay1ms(200);
 705   3      
 706   3                  Drv_Gpio_ModeSet(GPIO3_DHRX_DCAUXP, OUT_PP_2x | NO_PU_PD, VOL_3_3);
 707   3                  Drv_IOSoftLevel_Set(GPIO3_DHRX_DCAUXP, HIGH); // GPIO3 ËÉåÂÖâ
 708   3                  Ocm_Delay1ms(50);
 709   3      
 710   3                  Drv_Gpio_ModeSet(GPIO24_PWM2, OUT_PP_2x | NO_PU_PD, VOL_3_3);
 711   3                  Drv_IOSoftLevel_Set(GPIO24_PWM2, HIGH); // GPIO24 PWM
 712   3                  Ocm_Delay1ms(50);
 713   3      
 714   3      #endif
 715   3      
 716   3                  if (MIPITX_DPHY == g_stMipiTx.ucTxPhySel)
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:48:29 PAGE 13  

 717   3                  {
 718   4                      Drv_MipiTx_DPhyClkHsTrig();
 719   4                      Drv_MipiTx_DPhySkewCali();
 720   4                  }
 721   3      
 722   3                  Drv_MipiTx_VideoSet(ON);
 723   3                  Mod_MipiTx_SetState(STATE_MIPITX_AUDIO_OUT_6);
 724   3              }
 725   2              break;
 726   2          case STATE_MIPITX_AUDIO_OUT_6:
 727   2              Drv_Audio_Init();
 728   2      #if TDM_SUPPORT == ENABLED
                      Drv_Audio_TdmOutInit();
              #endif
 731   2              Mod_MipiTx_SetState(STATE_MIPITX_PLAY_BACK_7);
 732   2              break;
 733   2          case STATE_MIPITX_PLAY_BACK_7:
 734   2              break;
 735   2          default:
 736   2              break;
 737   2          }
 738   1      }
 739          
 740          void Mod_MipiTx_Handler(void)
 741          {
 742   1          Mod_MipiTx_StateHandler();
 743   1          Mod_MipiTx_EventProc();
 744   1      }
 745          
 746          void Mod_MIPITx_Pattern(void)
 747          {
 748   1      #if MIPITX_VID_PATTERN_MODE != NO_PATTERN
 749   1          ModPattern_Init();
 750   1          g_stMipiTx.b1UpstreamVideoReady = TRUE;
 751   1          g_stMipiTx.b1UpstreamDeviceReady = TRUE;
 752   1      
 753   1      #if CSC_SUPPORT == ENABLED
              
              #if ((CHIP_SEL == LT6911GXD_HD) || (CHIP_SEL == LT7911UXE_HD))
                  LT6911GXE_HdmiRxCscOrEncSel();
                  LT6911GXE_HdmiRxCscCvt();
              #endif
              
              #if ((CHIP_SEL == LT7911UXE_DP) || (CHIP_SEL == LT6911GXD_DP))
                  LT7911GXE_DpRxCscOrEncSel();
                  LT7911GXE_DpRxCscCvt();
              #endif
              
              #endif
 766   1          while (1)
 767   1          {
 768   2              Mod_MipiTx_Handler();
 769   2          }
 770   1      #endif
 771   1      }
 772          
 773          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3141    ----
   CONSTANT SIZE    =    999    ----
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/21/2025 11:48:29 PAGE 14  

   XDATA SIZE       =    609      53
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
