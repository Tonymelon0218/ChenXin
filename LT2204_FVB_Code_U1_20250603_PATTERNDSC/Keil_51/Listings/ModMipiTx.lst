C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/11/2025 13:52:36 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MODMIPITX
OBJECT MODULE PLACED IN .\Objects\ModMipiTx.obj
COMPILER INVOKED BY: D:\DevTools\Keil_5\Keil_v5\C51\BIN\C51.EXE ..\User\L1_Module\ModMipiTx.c LARGE OBJECTADVANCED OPTIM
                    -IZE(11,SIZE) REGFILE(.\Objects\LT6911GXD_Pattern_MIPI_3D_NoBurst_4320x2160@90_25111103.ORC) BROWSE INCDIR(..\User\L0_App
                    -;..\User\L1_Module;..\User\L2_Drive;..\User\L3_Ocm) DEBUG PRINT(.\Listings\ModMipiTx.lst) OBJECT(.\Objects\ModMipiTx.obj
                    -)

line level    source

   1          /******************************************************************************
   2            * @project: LT2204
   3            * @file: ChipMipi.c
   4            * @author: wtt
   5            * @company: LONTIUM
   6            * @date: 2022.05.26
   7          /******************************************************************************/
   8          #include "include.h"
   9          
  10          #if TX_PORT_SIGN == MIPI_PORT
  11          
  12          StructMipiTx g_stMipiTx;
  13          StructTiming g_stMipiTxVideoTiming;
  14          
  15          u8 code szMipiEdid[512] =
  16              {
  17                  0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 0xB3, 0xA0, 0x28, 0x01, 0x01, 0x01, 0x01,
  18                  0x04, 0x1F, 0x01, 0x03, 0x80, 0x3E, 0x22, 0x78, 0xEE, 0x69, 0x95, 0xAD, 0x52, 0x46, 0xA1, 0x27,
  19                  0x0F, 0x50, 0x54, 0xBF, 0xCF, 0x00, 0x81, 0x40, 0x81, 0x80, 0x95, 0x00, 0x71, 0x4F, 0x81, 0xC0,
  20                  0xB3, 0x00, 0xD1, 0xC0, 0x01, 0x01, 0x08, 0xE8, 0x00, 0x30, 0xF2, 0x70, 0x5A, 0x80, 0xB0, 0x58,
  21                  0x8A, 0x00, 0x55, 0x50, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x18, 0x90, 0x1E,
  22                  0xFF, 0x8A, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x56,
  23                  0x47, 0x32, 0x38, 0x55, 0x51, 0x4C, 0x31, 0x41, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFF,
  24                  0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x32, 0x38, 0x0A, 0x01, 0xF0,
  25                  0x02, 0x03, 0x5A, 0xF1, 0x50, 0x04, 0x13, 0x1F, 0x10, 0x0F, 0x1E, 0x01, 0x5D, 0x5E, 0x5F, 0x60,
  26                  0x61, 0x76, 0x03, 0x12, 0x3F, 0x23, 0x09, 0x07, 0x07, 0x83, 0x01, 0x00, 0x00, 0xE2, 0x00, 0xEA,
  27                  0x6D, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x38, 0x3C, 0x28, 0x00, 0x60, 0x01, 0x02, 0x03, 0x6D, 0xD8,
  28                  0x5D, 0xC4, 0x01, 0x78, 0x88, 0x53, 0x12, 0x30, 0x78, 0x83, 0x34, 0x1D, 0x6D, 0x1A, 0x00, 0x00,
  29                  0x02, 0x01, 0x30, 0x90, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x05, 0xC0, 0x00, 0xE4, 0x21,
  30                  0x00, 0x1C, 0x00, 0xE6, 0x06, 0x05, 0x01, 0x60, 0x60, 0x12, 0x36, 0x6C, 0x80, 0xA0, 0x70, 0x70,
  31                  0x3E, 0x80, 0x30, 0x20, 0x08, 0x0C, 0x6D, 0x55, 0x21, 0x00, 0x00, 0x1A, 0x6F, 0xC2, 0x00, 0xA0,
  32                  0xA0, 0xA0, 0x55, 0x50, 0x30, 0x20, 0x35, 0x00, 0x6D, 0x55, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x27};
  33          
  34          u8 szEdidData[512];
  35          
  36          StructMipiVideoFmtCfg g_MipiVideoFmtCfg[] =
  37              {
  38          #if MIPITX_PRO_SEL == MIPITX_DSI
  39                  {DSI_RGB_565, 16, 0x00, 0x0E, MIPITX_DSI},
  40                  {DSI_RGB_666, 18, 0x10, 0x1E, MIPITX_DSI},
  41                  {DSI_RGB_888, 24, 0x21, 0x3E, MIPITX_DSI}, // ÈªòËÆ§DSI
  42                  {DSI_RGB_30, 30, 0x41, 0x0D, MIPITX_DSI},
  43                  {DSI_YUV422_16Bit, 16, 0x01, 0x2C, MIPITX_DSI},
  44                  {DSI_YUV422_20Bit, 24, 0x24, 0x0C, MIPITX_DSI}, // ÊåâÁÖß24bitÂèëÈÄÅ 422 20 spec
  45                  {DSI_YUV422_24Bit, 24, 0x23, 0x1C, MIPITX_DSI},
  46                  {DSI_YUV420_12Bit, 24, 0x20, 0x3D, MIPITX_DSI}, // TODO:
  47          #else
                      {CSI_RGB_565, 16, 0x02, 0x22, MIPITX_CSI},
                      {CSI_RGB_666, 18, 0x11, 0x23, MIPITX_CSI},
                      {CSI_RGB_888, 24, 0x25, 0x24, MIPITX_CSI},
                      {CSI_YUV422_8Bit, 16, 0x01, 0x1E, MIPITX_CSI}, // ÈªòËÆ§CSI
                      {CSI_YUV422_10Bit, 20, 0x31, 0x1F, MIPITX_CSI},
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/11/2025 13:52:36 PAGE 2   

                      {CSI_YUV420_8Bit, 24, 0x20, 0x1A, MIPITX_CSI}
              #endif
  55          };
  56          
  57          void Mod_MipiTx_PowerOnInit(void)
  58          {
  59   1          memset(&g_stMipiTx, 0, sizeof(StructMipiTx));
  60   1          g_stMipiTx.ucTxState = STATE_MIPITX_POWER_ON_1;
  61   1      
  62   1      #if (MIPITX_PRO_SEL == MIPITX_CSI)
                  Drv_MipiTx_CSIFeSoftwareSendInit();
              #endif
  65   1      }
  66          
  67          void Mod_MipiTx_SetState(u8 ucState)
  68          {
  69   1          if (ucState != g_stMipiTx.ucTxState)
  70   1          {
  71   2      #if (MIPITX_PRO_SEL == MIPITX_CSI)
              #if (1 == CSI_SOFTWARE_SEND_FE)
                      if (STATE_MIPITX_PLAY_BACK_8 == g_stMipiTx.ucTxState))
                          {
                              Drv_MipiTx_CSIFeSoftwareSend();
                              LTLog(LOG_INFO, "CSI Software Send Frame End");
                          }
              #endif
              #endif
  80   2      
  81   2              if (ucState == STATE_MIPITX_VIDEO_OUT_5)
  82   2              {
  83   3                  TX_Event_Set(TX_VIDEO_ON_EVENT_3);
  84   3              }
  85   2              g_stMipiTx.ucTxStateChangeFlag = TRUE;
  86   2              g_stMipiTx.ucTxState = ucState;
  87   2              LTLog(LOG_DEBUG, "TxState = 0x%02bx", ucState);
  88   2          }
  89   1      }
  90          
  91          // TODO: Â§ñÁïåÂÅö‰∏Ä‰∏™Êé•Âè£ÔºåÂØπÂÜÖÂè™Ê∂âÂèäRX Ôºàun)plug„ÄÅvideo on/off,‰∏çÁî®ÁªÜÂàÜÊòØdp ËøòÊòØhdmi
  92          /*
  93          0 : Source unplug 1:source plug
  94          2: video  OFF     3:video ON
  95          */
  96          void Mod_LMTx_EventMonitor(u8 ucMsgType)
  97          {
  98   1      #define SOURECE_PLUG_EVENT 1
  99   1      #define SOURECE_UNPLUG_EVENT 2
 100   1      #define VIDEO_ON_EVENT 3
 101   1      #define VIDEO_OFF_EVENT 4
 102   1      
 103   1          switch (ucMsgType)
 104   1          {
 105   2          case SOURECE_UNPLUG_EVENT: // HDMIRX_SOURECE_UNPLUG_EVENT  DPRX_SOURECE_UNPLUG_EVENT:
 106   2              g_stMipiTx.b1UpstreamDeviceReady = FALSE;
 107   2              LTLog(LOG_INFO, "RX Set Event:%02bx ", ucMsgType);
 108   2              break;
 109   2          case SOURECE_PLUG_EVENT: // HDMIRX_SOURECE_PLUG_EVENT DPRX_SOURECE_PLUG_EVENT
 110   2              g_stMipiTx.b1UpstreamDeviceReady = TRUE;
 111   2              LTLog(LOG_INFO, "RX Set Event:%02bx ", ucMsgType);
 112   2              break;
 113   2          case VIDEO_OFF_EVENT: // HDMIRX_VIDEO_OFF_EVENT DPRX_VIDEO_OFF_EVENT
 114   2              g_stMipiTx.b1UpstreamVideoReady = FALSE;
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/11/2025 13:52:36 PAGE 3   

 115   2              LTLog(LOG_INFO, "RX Set Event:%02bx ", ucMsgType);
 116   2              break;
 117   2          case VIDEO_ON_EVENT: // HDMIRX_VIDEO_ON_EVENT DPRX_VIDEO_ON_EVENT
 118   2              g_stMipiTx.b1UpstreamVideoReady = TRUE;
 119   2              LTLog(LOG_INFO, "RX Set Event:%02bx ", ucMsgType);
 120   2              break;
 121   2          default:
 122   2              break;
 123   2          }
 124   1      }
 125          
 126          u8 Mod_MipiTx_VidEnCmd_Get(u8 IsCtrlEn, u8 UserReg)
 127          {
 128   1          if (IsCtrlEn == ENABLED)
 129   1          {
 130   2              if (UserReg != 0)
 131   2              {
 132   3                  return ON;
 133   3              }
 134   2              return OFF;
 135   2          }
 136   1          return ON;
 137   1      }
 138          
 139          void Mod_MipiTx_EventProc()
 140          {
 141   1          u8 ucMinState = 0xFF;
 142   1      
 143   1          if (g_stMipiTx.ucTxState > STATE_MIPITX_UPSTREAM_DEVICE_READY_2)
 144   1          {
 145   2              if (g_stMipiTx.b1UpstreamDeviceReady == FALSE)
 146   2              {
 147   3                  Mod_MipiTx_SetState(STATE_MIPITX_UPSTREAM_DEVICE_READY_2);
 148   3              }
 149   2          }
 150   1      
 151   1          if (g_stMipiTx.ucTxState > STATE_MIPITX_UPSTREAM_VIDEO_READY_3)
 152   1          {
 153   2              if (g_stMipiTx.b1UpstreamVideoReady == FALSE)
 154   2              {
 155   3                  Mod_MipiTx_SetState(STATE_MIPITX_UPSTREAM_VIDEO_READY_3);
 156   3              }
 157   2          }
 158   1      
 159   1          if (g_stMipiTx.ucTxState >= STATE_MIPITX_VIDEO_OUT_5)
 160   1          {
 161   2      #if MIPI_OUT_CTRL == ENABLED
                      if (Mod_MipiTx_VidEnCmd_Get(ENABLED, USER_VIDEOEN_REG) == OFF) // default off
              #else
 164   2              if (Mod_MipiTx_VidEnCmd_Get(DISABLED, USER_VIDEOEN_REG) == OFF) // default on
 165   2      #endif
 166   2              {
 167   3                  if (g_stMipiTx.b1MIPITXStreamOn == ON)
 168   3                  {
 169   4                      g_stMipiTx.b1MIPITXStreamOn = OFF;
 170   4                      Drv_MipiTx_Rst(DISABLED);
 171   4                      Drv_MipiTx_VideoSet(OFF);
 172   4                  }
 173   3              }
 174   2              else
 175   2              {
 176   3                  if (g_stMipiTx.b1MIPITXStreamOn == OFF)
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/11/2025 13:52:36 PAGE 4   

 177   3                  {
 178   4                      ucMinState = min(ucMinState, STATE_MIPITX_VIDEO_OUT_5);
 179   4                      g_stMipiTx.b1MIPITXStreamOn = ON;
 180   4                  }
 181   3              }
 182   2          }
 183   1      
 184   1          if (ucMinState != 0xFF)
 185   1          {
 186   2              Mod_MipiTx_SetState(ucMinState);
 187   2          }
 188   1      }
 189          
 190          void Mod_MipiTx_PllSet()
 191          {
 192   1          u32 ulByteclk, ulPhyClk;
 193   1      
 194   1          ulPhyClk = g_stMipiTx.ulMipiDataRate;
 195   1          ulByteclk = ulPhyClk >> 3;
 196   1          LTLog(LOG_DEBUG, "MipiInClk:%ld, calc ulByteclk:%ld, ulPhyClk:%ld, ucBpp:%bd, ucTxPortNum:0x%02bx, ucT
             -xLaneNum:0x%02bx",
 197   1                g_stMipiTx.ulMipiInClk, ulByteclk, ulPhyClk, g_stMipiTx.ucBpp, g_stMipiTx.ucTxPortNum, g_stMipiT
             -x.ucTxLaneNum);
 198   1      
 199   1          Drv_MipiTx_PllSet(ulPhyClk);
 200   1      }
 201          
 202          u8 Mod_MipiTx_PllCaliIfSucc()
 203          {
 204   1          return Drv_MipiTx_PllCali();
 205   1      }
 206          
 207          void Mod_MipiTx_PhyTimingSet()
 208          {
 209   1          u32 ulMipiDataRate = g_stMipiTx.ulMipiDataRate;
 210   1          u8 b1MipiClockburst = g_stMipiTx.b1MipiClockburst;
 211   1          u8 ucPhySel = g_stMipiTx.ucTxPhySel;
 212   1          u8 ucDphyCsi8Lane = g_stMipiTx.b1DphyCsi8Lane;
 213   1          Drv_MipiTx_PhyTimingParaSet(ulMipiDataRate, b1MipiClockburst, ucPhySel, ucDphyCsi8Lane);
 214   1      }
 215          
 216          u8 Mod_MipiTx_BppCalculate(u8 ucMIPIDataFmt)
 217          {
 218   1          u8 ucBpp = 24;
 219   1          u8 ucIndex = 0;
 220   1          for (ucIndex = 0; ucIndex < sizeof(g_MipiVideoFmtCfg) / sizeof(g_MipiVideoFmtCfg[0]); ucIndex++)
 221   1          {
 222   2              if (ucMIPIDataFmt == g_MipiVideoFmtCfg[ucIndex].ucVideoFmt)
 223   2              {
 224   3                  ucBpp = g_MipiVideoFmtCfg[ucIndex].ucBpp;
 225   3                  break;
 226   3              }
 227   2          }
 228   1      
 229   1          return ucBpp;
 230   1      }
 231          
 232          void Mod_MipiTx_PortLaneAdj()
 233          {
 234   1      #if MIPITX_PRO_SEL == MIPITX_CSI
                  if (MIPITX_DPHY == g_stMipiTx.ucTxPhySel)
                  {
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/11/2025 13:52:36 PAGE 5   

                      if (g_stMipiTx.ulMipiInClk > 600000) // over 4K60
                      {
                          g_stMipiTx.ucTxPortNum = MIPI_2PORT; // TODO: ÈªòËÆ§ÊòØCSI 8lane1901 Â¶ÇÊûúË∂ÖËøá600m
                          g_stMipiTx.ucTxLaneNum = MIPI_PORT_4LANE;
                      }
                      //        else
                      //        {
                      //            g_stMipiTx.ucTxPortNum = MIPI_1PORT;
                      //            g_stMipiTx.ucTxLaneNum = MIPI_PORT_4LANE;
                      //        }
                  }
              #endif
 249   1      
 250   1          if (MIPITX_CPHY == g_stMipiTx.ucTxPhySel)
 251   1          {
 252   2              if (g_stMipiTx.ucTxLaneNum > MIPI_PORT_3LANE) // for cphy , up to 3lane
 253   2              {
 254   3                  g_stMipiTx.ucTxLaneNum = MIPI_PORT_3LANE;
 255   3              }
 256   2          }
 257   1      }
 258          
 259          void Mod_MipiTx_CfgParaInit()
 260          {
 261   1          u32 ulMipiInClk;
 262   1          g_stMipiTx.ucTxLaneNum = MIPI_LANE_NUM;
 263   1          g_stMipiTx.b1MipiClockburst = MIPI_CLOCK_BURST;
 264   1          g_stMipiTx.b1DSIVideoMode = MIPI_DSI_VIDEO_MODE;
 265   1          g_stMipiTx.ucTxPhySel = MIPITX_PHY_SEL;
 266   1          g_stMipiTx.ucTxFormat = MIPITX_VIDEO_FORMAT;
 267   1      
 268   1      #if RX_PORT_SIGN == DP_PORT
 269   1      #if CUSTOM_EDID_SWITCH == ENABLED
              
              #else
 272   1          g_stMipiTx.ucTxPortNum = MIPI_PORT_NUM;
 273   1          g_stMipiTx.uc3DMode = MIPITX_3D_MODE_SEL;
 274   1      #endif
 275   1      #endif
 276   1      
 277   1      #if RX_PORT_SIGN == HDMI_PORT
                  g_stMipiTx.ucTxPortNum = MIPI_PORT_NUM;
                  g_stMipiTx.uc3DMode = MIPITX_3D_MODE_SEL;
              #endif
 281   1      
 282   1          g_stMipiTx.ucBpp = Mod_MipiTx_BppCalculate(g_stMipiTx.ucTxFormat);
 283   1          g_stMipiTx.b1MIPITXStreamOn = OFF;
 284   1      
 285   1          g_stMipiTx.b1MIPITXProSel = MIPITX_PRO_SEL;
 286   1          // Get input BPP
 287   1          ulMipiInClk = Drv_MipiTx_GetMipiInClk();
 288   1          if (0 != ulMipiInClk)
 289   1          {
 290   2              g_stMipiTx.ulMipiInClk = ulMipiInClk;
 291   2          }
 292   1          // adjust port or lane
 293   1          Mod_MipiTx_PortLaneAdj();
 294   1      }
 295          void Mod_MipiTx_DataRateAdj()
 296          {
 297   1          if (MIPITX_DPHY == g_stMipiTx.ucTxPhySel)
 298   1          {
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/11/2025 13:52:36 PAGE 6   

 299   2              g_stMipiTx.ulMipiDataRate = g_stMipiTx.ulMipiInClk * 2 * g_stMipiTx.ucBpp / (g_stMipiTx.ucTxPortNu
             -m * g_stMipiTx.ucTxLaneNum);
 300   2          }
 301   1          else
 302   1          {
 303   2              g_stMipiTx.ulMipiDataRate = g_stMipiTx.ulMipiInClk * 2 * g_stMipiTx.ucBpp * 7 / (16 * g_stMipiTx.u
             -cTxPortNum * g_stMipiTx.ucTxLaneNum);
 304   2          }
 305   1      
 306   1          if (MIPI_NO_3D_MODE != g_stMipiTx.uc3DMode) // ref 1901
 307   1          {
 308   2              g_stMipiTx.ulMipiDataRate += 115000;
 309   2          }
 310   1          else
 311   1          {
 312   2              g_stMipiTx.ulMipiDataRate += 80000;
 313   2          }
 314   1      
 315   1          if (g_stMipiTx.b1MipiClockburst) // ref 2102
 316   1          {
 317   2              g_stMipiTx.ulMipiDataRate += 80000;
 318   2              LTLog(LOG_INFO, "Burst Mode lane rate increase 80M");
 319   2          }
 320   1      
 321   1          if (g_stMipiTx.ulMipiDataRate < MIPITX_PLL_LOW) // set byteclk minium value to 50M , phyclk minium val
             -ue is 400M
 322   1          {
 323   2              g_stMipiTx.ulMipiDataRate = MIPITX_PLL_LOW;
 324   2          }
 325   1          if (g_stMipiTx.ulMipiDataRate > MIPITX_PLL_HIGH) // set byteclk maxmum value to 312.5M , phyclk maxmum
             - value is 2.5G
 326   1          {
 327   2              g_stMipiTx.ulMipiDataRate = MIPITX_PLL_HIGH;
 328   2          }
 329   1      }
 330          
 331          void Mod_MipiTx_SetDataType(u8 ucVideoFormat)
 332          {
 333   1      #if MIPITX_PRO_SEL == MIPITX_DSI
 334   1          u8 ucDataType = 0x3E;
 335   1          u8 ucBppAndFmtSel = 0x21; // rgb 888
 336   1      #else
                  u8 ucDataType = 0x1E;
                  u8 ucBppAndFmtSel = 0x01; // CSI 422 8bit
              #endif
 340   1          u8 ucIndex = 0;
 341   1      
 342   1      #if MIPITX_DSC != ENABLED
                  for (ucIndex = 0; ucIndex < sizeof(g_MipiVideoFmtCfg) / sizeof(g_MipiVideoFmtCfg[0]); ucIndex++)
                  {
                      if (ucVideoFormat == g_MipiVideoFmtCfg[ucIndex].ucVideoFmt)
                      {
                          ucDataType = g_MipiVideoFmtCfg[ucIndex].ucDatatype;
                          ucBppAndFmtSel = g_MipiVideoFmtCfg[ucIndex].ucBppAndFmtsel;
                          break;
                      }
                  }
              #else
 353   1          // todo:
 354   1          ucDataType = 0x0B;
 355   1          ucBppAndFmtSel = 0x25;
 356   1      #endif
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/11/2025 13:52:36 PAGE 7   

 357   1      
 358   1      #if RX_PORT_SIGN == DP_PORT
 359   1      #if (DPRX_DSC_BYPASS_SUPPORT == ENABLED)
                  if (Drv_DpRxDscBy_SwitchGet() == ENABLED)
                  {
                      ucDataType = 0x0B;
                      ucBppAndFmtSel = 0x25;
                  }
              #endif
 366   1      #endif
 367   1      
 368   1      #if RX_PORT_SIGN == HDMI_PORT
              #if (HDMIRX_DSC_BYPASS_SUPPORT == ENABLED)
                  if (Drv_HdmiRxDscBy_SwitchGet() == ENABLED)
                  {
                      ucDataType = 0x0B;
                      ucBppAndFmtSel = 0x25;
                  }
              #endif
              #endif
 377   1      
 378   1          Drv_MipiTx_DataTypeSet(ucDataType, ucBppAndFmtSel);
 379   1      }
*** WARNING C280 IN LINE 331 OF ..\User\L1_Module\ModMipiTx.c: 'ucVideoFormat': unreferenced local variable
 380          
 381          void Mod_MipiTx_Resolution_Config()
 382          {
 383   1          // Ëé∑Âèñtiming‰ø°ÊÅØ
 384   1          memset(&g_stMipiTxVideoTiming, 0, sizeof(StructTiming));
 385   1          Drv_VideoCheckAll_Get(&g_stMipiTxVideoTiming);
 386   1          LTLog(LOG_INFO, "RX[H]: Htotal:%d,Hactive:%d,Hsw:%d,Hfp:%d,Hbp:%d,Hspol:%bd", g_stMipiTxVideoTiming.Ht
             -otal, g_stMipiTxVideoTiming.Hactive, g_stMipiTxVideoTiming.Hsw, g_stMipiTxVideoTiming.Hfp, g_stMipiTxVideoTiming.Hbp, g_
             -stMipiTxVideoTiming.Hspol);
 387   1          LTLog(LOG_INFO, "RX[V]: Vtotal:%d,Vactive:%d,Vsw:%d,Vfp:%d,Vbp:%d,Vspol:%bd", g_stMipiTxVideoTiming.Vt
             -otal, g_stMipiTxVideoTiming.Vactive, g_stMipiTxVideoTiming.Vsw, g_stMipiTxVideoTiming.Vfp, g_stMipiTxVideoTiming.Vbp, g_
             -stMipiTxVideoTiming.Vspol);
 388   1          // ËÆæÁΩÆmipi timing‰ø°ÊÅØ
 389   1          Drv_MipiTx_TimingSet(&g_stMipiTxVideoTiming);
 390   1      
 391   1          // ÊûÅÊÄßËé∑Âèñ
 392   1          Drv_MipiTx_InHSyncPol_Sel(g_stMipiTxVideoTiming.Hspol);
 393   1          Drv_MipiTx_InVSyncPol_Sel(g_stMipiTxVideoTiming.Vspol);
 394   1      }
 395          
 396          void Mod_MipiTx_Digital_Config()
 397          {
 398   1          Drv_MipiTx_Rst(ENABLED);
 399   1          Drv_MipiTx_LaneSwap(); // if need adjust lane,please modify
 400   1          Drv_MipiTx_PortSwap(g_stMipiTx.ucTxPortNum);
 401   1          Drv_MipiTx_PortNumSet(g_stMipiTx.ucTxPortNum);
 402   1          Drv_MipiTx_LaneNumSet(g_stMipiTx.ucTxLaneNum);
 403   1          LTLog(LOG_INFO, "Port: %02bx, Lane: %02bx", g_stMipiTx.ucTxPortNum, g_stMipiTx.ucTxLaneNum);
 404   1      #if MIPITX_PHY_SEL == MIPITX_CPHY
                  Drv_MipiTx_CPhyEn(ENABLED);
                  LTLog(LOG_INFO, "select Mipi Cphy");
                  // TODO: ËøôÈáåÊ≤°Êúâclk ÂèØ‰ª•ÈÄâÊã©ÔºåÊï∞Â≠óÂíåÊ®°ÊãüÈÉΩÊú™Êèê‰æõÔºå‰∏çÂΩ±ÂìçDphy‰ª•ÂèäÈùû8lane Dphy
             - CSI
                  SET_BIT(BKA3_7B_REG, BIT2);
              #else
 410   1          Drv_MipiTx_DPhyClkDataSet();
 411   1          Drv_MipiTx_DPhyClkModeSet(g_stMipiTx.b1MipiClockburst);
 412   1      #if MIPITX_PRO_SEL == MIPITX_DSI
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/11/2025 13:52:36 PAGE 8   

 413   1          Drv_MipiTx_DSIVideoModeSet(g_stMipiTx.b1DSIVideoMode);
 414   1      #endif
 415   1          CLEAR_BIT(BKA3_7B_REG, BIT2);
 416   1          if (g_stMipiTx.b1DphyCsi8Lane)
 417   1          {
 418   2              // TODO: DPHY CSI 8Lane Êó†Ê≥ïÈÄâÊã©write clk
 419   2              SET_BIT(BKA3_7B_REG, BIT2);
 420   2              Drv_MipiTx_DPhyCSI8LaneEn(ENABLED);
 421   2          }
 422   1          Drv_MipiTx_EotpSet(ENABLED);
 423   1      
 424   1      #endif
 425   1          Drv_MipiTx_PhyModeSet(g_stMipiTx.ucTxPhySel);
 426   1          Drv_MipiTx_LmtxModeSet(g_stMipiTx.ucTxPhySel);
 427   1          Drv_MipiTx_LmtxSrcSet();
 428   1          Drv_MipiTx_LmtxInputDataSet();
 429   1          Drv_MipiTx_LmtxSramInputSet();
 430   1          // TODO: 0xF97A bit 4 - MIPI protocol vactive select:HW or SW?
 431   1      #if (MIPITX_PRO_SEL == MIPITX_CSI)
                  // ÂºÄÂêØ CSI frame number enable.
                  Drv_MipiTx_FrameCntSet(ON);
              #else
 435   1          Drv_MipiTx_HssLP_En(MIPITX_HSS_BURST_EN);
 436   1          Drv_MipiTx_FrameCntSet(OFF);
 437   1      #endif
 438   1      
 439   1          Drv_MipiTx_3DModeSet(g_stMipiTx.uc3DMode);
 440   1      
 441   1          Mod_MipiTx_SetDataType(g_stMipiTx.ucTxFormat);
 442   1      
 443   1      #if RX_PORT_SIGN == DP_PORT
 444   1      #if (DPRX_DSC_BYPASS_SUPPORT == ENABLED)
                  if (Drv_DpRxDscBy_SwitchGet() == ENABLED)
                  {
                      LTLog(LOG_INFO, "DSC soft wordcnt;");
                      Drv_MipiTx_WordCnt_Set(SW_MODE, g_stDpRxDscByTiming.usHact / g_stMipiTx.ucTxPortNum, g_stMipiTx.uc
             -TxPortNum);
                      Drv_MipiTx_Dsc_Split(g_stMipiTxVideoTiming.Hactive, g_stMipiTx.ucTxPortNum);
                  }
              #endif
 452   1      #endif
 453   1      
 454   1      #if MIPITX_DSC == ENABLED
 455   1          LTLog(LOG_INFO, "DSC soft wordcnt;");
 456   1          Drv_MipiTx_WordCnt_Set(SW_MODE, g_stMipiTxDscEncVideoTiming.Hactive / g_stMipiTx.ucTxPortNum, g_stMipi
             -Tx.ucTxPortNum);
 457   1          Drv_MipiTx_Dsc_Split(g_stMipiTxVideoTiming.Hactive, g_stMipiTx.ucTxPortNum);
 458   1      #endif
 459   1      }
 460          
 461          void Mod_MipiTx_Anolog_Config()
 462          {
 463   1          Drv_MipiTx_PhySet(MP0_EN, MP1_EN, MP2_EN, MP3_EN);
 464   1      }
 465          
 466          void Mod_MipiTx_HssSet()
 467          {
 468   1          u16 Hss = 0x0A;
 469   1      #if (MIPITX_PRO_SEL == MIPITX_CSI)
                  if (MIPITX_DPHY == g_stMipiTx.ucTxPhySel)
                  {
                      if (g_stMipiTx.b1MipiClockburst == ENABLED)
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/11/2025 13:52:36 PAGE 9   

                      {
                          Hss = (3 * Drv_mipiTx_GetHsRqstPre() + Drv_MipiTx_GetHsTrail() + 9) / 2 + 20;
                      }
                      else
                      {
                          Hss = (Drv_mipiTx_GetHsRqstPre() + (Drv_MipiTx_GetHsTrail() + 13) / 2) + 20;
                      }
                  }
              #else
 482   1          if (MIPITX_CPHY == g_stMipiTx.ucTxPhySel)
 483   1          {
 484   2              if (3 != g_stMipiTx.ucTxLaneNum)
 485   2              {
 486   3                  Hss = 0x20;
 487   3              }
 488   2          }
 489   1      #if MIPITX_HSCMD_EN == ENABLED
                  {
                      Hss = MIPITX_HSCMD_HSSLEN;
                  }
              #endif
 494   1      #endif
 495   1      
 496   1          Drv_MipiTx_Hss_Set(Hss);
 497   1      }
 498          
 499          void Mod_MipiTx_FifoRddly_Config()
 500          {
 501   1          u16 rdpixclk, rdbyteclk, rdhss, rgodhact;
 502   1          u32 rddly, rddly_max, rddly_min1, rddly_min2;
 503   1          u32 Temp;
 504   1      
 505   1          rdpixclk = (u16)(g_stMipiTx.ulMipiInClk / 1000);
 506   1          rdbyteclk = (u16)(g_stMipiTx.ulMipiDataRate / 2000);
 507   1          if (MIPITX_DPHY == g_stMipiTx.ucTxPhySel)
 508   1          {
 509   2              rdbyteclk /= 8;
 510   2          }
 511   1          else
 512   1          {
 513   2              rdbyteclk /= 7;
 514   2          }
 515   1      
 516   1          if ((ENABLED == g_stMipiTx.b1DphyCsi8Lane) || (MIPITX_CPHY == g_stMipiTx.ucTxPhySel))
 517   1          {
 518   2              rdbyteclk <<= 1;
 519   2          }
 520   1          rdbyteclk *= g_stMipiTx.ucTxPortNum;
 521   1          rdhss = Drv_MipiTx_Hss_Get();
 522   1          rgodhact = Drv_MipiTx_FSMHact_Get();
 523   1      
 524   1          LTLog(LOG_DEBUG, "rdbyteclk:%d, rdpixclk:%d ", rdbyteclk, rdpixclk);
 525   1          LTLog(LOG_DEBUG, "hsw:%d, hbp:%d hactive:%d", g_stMipiTxVideoTiming.Hsw, g_stMipiTxVideoTiming.Hbp, g_
             -stMipiTxVideoTiming.Hactive);
 526   1      
 527   1          Temp = (rdbyteclk * (g_stMipiTxVideoTiming.Hsw / 2 + g_stMipiTxVideoTiming.Hbp / 2) / rdpixclk);
 528   1          if (Temp > rdhss)
 529   1          {
 530   2              rddly_min1 = (rdbyteclk * (g_stMipiTxVideoTiming.Hsw / 2 + g_stMipiTxVideoTiming.Hbp / 2) / rdpixc
             -lk) - rdhss;
 531   2          }
 532   1          else
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/11/2025 13:52:36 PAGE 10  

 533   1          {
 534   2              rddly_min1 = 0;
 535   2          }
 536   1      
 537   1          if (1 == g_stMipiTx.ucTxPortNum)
 538   1          {
 539   2              rddly_min2 = (u32)rdbyteclk * (g_stMipiTxVideoTiming.Hsw / 2 + g_stMipiTxVideoTiming.Hbp / 2 + g_s
             -tMipiTxVideoTiming.Hactive / 2);
 540   2              Temp = ((u32)rddly_min2 / (u32)rdpixclk);
 541   2              if (Temp > (rdhss + rgodhact))
 542   2              {
 543   3                  rddly_min2 = (u32)(((u32)rddly_min2 / (u32)rdpixclk) - rdhss - rgodhact);
 544   3              }
 545   2              else
 546   2              {
 547   3                  rddly_min2 = 0;
 548   3              }
 549   2          }
 550   1          else
 551   1          {
 552   2              rddly_min2 = rddly_min1;
 553   2          }
 554   1      
 555   1          if (rddly_min1 > rddly_min2)
 556   1          {
 557   2              rddly_min2 = rddly_min1;
 558   2          }
 559   1      
 560   1          LTLog(LOG_DEBUG, "ucBpp 0x%02bx;", g_stMipiTx.ucBpp);
 561   1      
 562   1          rddly_max = 0x8000 / (g_stMipiTx.ucBpp << 1);
 563   1          rddly_max = rdbyteclk * (rddly_max + g_stMipiTxVideoTiming.Hsw / 2 + g_stMipiTxVideoTiming.Hbp / 2);
 564   1          rddly_max = rddly_max / (u32)rdpixclk - rdhss;
 565   1          // rddly = (rddly_max - rddly_min2) / 20 + rddly_min2;
 566   1          rddly = (rddly_max / 7) + rddly_min2;
 567   1      
 568   1          if (2 == g_stMipiTx.ucTxPortNum && g_stMipiTxVideoTiming.Hbp > 1000) // 720P 25Hz hbp=2268 ‰ª•‰∏äÂÖ¨Âº
             -è‰∏çÂèØÁî®
 569   1          {
 570   2              rddly = rddly_max / 7 + rddly_min2 / 2;
 571   2          }
 572   1      
 573   1          LTLog(LOG_INFO, "read delay:%lu", rddly);
 574   1      
 575   1          Drv_MipiTx_FifoDelay_Set(rddly);
 576   1      }
 577          
 578          void Mod_MipiTx_ByteClk_Chk(void)
 579          {
 580   1          u32 TempClock = 0;
 581   1      
 582   1          Drv_System_FmSet(TOP_FM, 0x31);
 583   1          Ocm_Delay1ms(5);
 584   1          TempClock = Drv_System_FmGet(TOP_FM, 0);
 585   1          LTLog(LOG_INFO, "Ad_lmtx_write_clk = %lukhz", TempClock);
 586   1      
 587   1          Drv_System_FmSet(TOP_FM, 0x30);
 588   1          Ocm_Delay1ms(5);
 589   1          TempClock = Drv_System_FmGet(TOP_FM, 0);
 590   1          LTLog(LOG_INFO, "Ad_lmtx_read_clk = %lukhz", TempClock);
 591   1      }
 592          
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/11/2025 13:52:36 PAGE 11  

 593          void Mod_MipiTx_StateHandler()
 594          {
 595   1          switch (g_stMipiTx.ucTxState)
 596   1          {
 597   2          case STATE_MIPITX_POWER_ON_1:
 598   2              Mod_MipiTx_SetState(STATE_MIPITX_UPSTREAM_DEVICE_READY_2);
 599   2              break;
 600   2      
 601   2          case STATE_MIPITX_UPSTREAM_DEVICE_READY_2:
 602   2              if (g_stMipiTx.ucTxStateChangeFlag)
 603   2              {
 604   3                  g_stMipiTx.ucTxStateChangeFlag = FALSE;
 605   3                  Drv_MipiTx_VideoSet(OFF);
 606   3                  Drv_GPIO19Vsync_Set(DISABLED);
 607   3      #if ((CHIP_SEL == LT6911GXD_HD) || (CHIP_SEL == LT7911UXE_HD))
                          g_stHdmiRx.b1DownstreamDeviceReady = TRUE;
              #if EDID_FLASH == ENABLED
                          {
                              Custom_EDID_LoadFromFlash();
                          }
              #else
                          memcpy(szEdidData, szMipiEdid, 512);
              #endif
              #endif
 617   3      
 618   3      #if ((CHIP_SEL == LT7911UXE_DP) || (CHIP_SEL == LT6911GXD_DP))
 619   3                  g_stDpRx.b1DownstreamDeviceReady = TRUE;
 620   3      #if EDID_FLASH == ENABLED
                          {
                              Custom_EDID_LoadFromFlash();
                          }
              #else
 625   3      #if CUSTOM_EDID_SWITCH == ENABLED
              
              #else
 628   3                  memcpy(szEdidData, szMipiEdid, 512);
 629   3      #endif
 630   3      #endif
 631   3      #endif
 632   3              }
 633   2      
 634   2              if (g_stMipiTx.b1UpstreamDeviceReady)
 635   2              {
 636   3                  Mod_MipiTx_SetState(STATE_MIPITX_UPSTREAM_VIDEO_READY_3);
 637   3              }
 638   2              break;
 639   2          case STATE_MIPITX_UPSTREAM_VIDEO_READY_3:
 640   2              if (g_stMipiTx.ucTxStateChangeFlag)
 641   2              {
 642   3                  g_stMipiTx.ucTxStateChangeFlag = FALSE;
 643   3                  Drv_MipiTx_VideoSet(OFF);
 644   3                  Drv_GPIO19Vsync_Set(DISABLED);
 645   3              }
 646   2      
 647   2              if (g_stMipiTx.b1UpstreamVideoReady)
 648   2              {
 649   3                  Mod_MipiTx_SetState(STATE_MIPITX_CONFIG_VIDEO_AUDIO_4);
 650   3      #if MIPITX_DSC == ENABLED
 651   3                  Drv_Sys_EncPowerDomain(FALSE);
 652   3                  // Drv_Gpio_ModeSet(GPIO6_D2, OUT_PP_2x | NO_PU_PD, VOL_3_3);//led ÈÄÇÈÖçÈ£ûÁ∫ø
 653   3                  Mod_MipiTxDscEnc_Config();
 654   3                  Ocm_Delay1ms(20);
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/11/2025 13:52:36 PAGE 12  

 655   3      #endif
 656   3      
 657   3                  Drv_Sys_DHTxPowerDomain(FALSE);
 658   3              }
 659   2              break;
 660   2      
 661   2          case STATE_MIPITX_CONFIG_VIDEO_AUDIO_4:
 662   2              Mod_MipiTx_CfgParaInit();
 663   2              Mod_MipiTx_DataRateAdj();
 664   2              Mod_MipiTx_PllSet();
 665   2      
 666   2              if (!Mod_MipiTx_PllCaliIfSucc())
 667   2              {
 668   3                  return;
 669   3              }
 670   2              Mod_MipiTx_Resolution_Config();
 671   2              Mod_MipiTx_PhyTimingSet();
 672   2              Mod_MipiTx_Digital_Config(); // TODO:
 673   2              Mod_MipiTx_Anolog_Config();  // TODO:
 674   2      
 675   2              Mod_MipiTx_HssSet();
 676   2              Mod_MipiTx_FifoRddly_Config();
 677   2              Mod_MipiTx_ByteClk_Chk();
 678   2      
 679   2              Mod_MipiTx_SetState(STATE_MIPITX_VIDEO_OUT_5);
 680   2              break;
 681   2          case STATE_MIPITX_VIDEO_OUT_5:
 682   2              if (g_stMipiTx.b1MIPITXStreamOn == ON)
 683   2              {
 684   3                  Drv_MipiTx_Rst(ENABLED);
 685   3      #if (MIPITX_PRO_SEL == MIPITX_DSI)
 686   3                  // 25090302: GPIO Control
 687   3                  Drv_Gpio_ModeSet(GPIO12_D1_VDET, OUT_PP_2x | NO_PU_PD, VOL_1_8);
 688   3                  Drv_IOSoftLevel_Set(GPIO12_D1_VDET, HIGH); // GPIO12 1.8V‰æõÁîµ
 689   3                  Ocm_Delay1ms(50);
 690   3      
 691   3                  Drv_Gpio_ModeSet(GPIO0_EARCN, OUT_PP_2x | NO_PU_PD, VOL_3_3);
 692   3                  Drv_IOSoftLevel_Set(GPIO0_EARCN, HIGH); // GPIO0 Ê≠£Ë¥üÁîµÂéã
 693   3                  Ocm_Delay1ms(50);
 694   3      
 695   3                  Drv_Gpio_ModeSet(GPIO15_D2_VDET, OUT_PP_2x | NO_PU_PD, VOL_3_3);
 696   3                  Drv_IOSoftLevel_Set(GPIO15_D2_VDET, HIGH); // GPIO15 Â§ç‰Ωç
 697   3                  Ocm_Delay1ms(5);
 698   3                  Drv_Gpio_ModeSet(GPIO1_EARCP, OUT_PP_2x | NO_PU_PD, VOL_3_3);
 699   3                  Drv_IOSoftLevel_Set(GPIO1_EARCP, HIGH); // GPIO1 Â§ç‰Ωç
 700   3                  Ocm_Delay1ms(200);
 701   3      
 702   3                  Mod_DCS_Init(); // ‰∏ãÂèëÂ±èÂèÇÊåá‰ª§
 703   3                  Ocm_Delay1ms(200);
 704   3      
 705   3                  Drv_Gpio_ModeSet(GPIO3_DHRX_DCAUXP, OUT_PP_2x | NO_PU_PD, VOL_3_3);
 706   3                  Drv_IOSoftLevel_Set(GPIO3_DHRX_DCAUXP, HIGH); // GPIO3 ËÉåÂÖâ
 707   3                  Ocm_Delay1ms(50);
 708   3      
 709   3                  Drv_Gpio_ModeSet(GPIO24_PWM2, OUT_PP_2x | NO_PU_PD, VOL_3_3);
 710   3                  Drv_IOSoftLevel_Set(GPIO24_PWM2, HIGH); // GPIO24 PWM
 711   3                  Ocm_Delay1ms(50);
 712   3      
 713   3      #endif
 714   3      
 715   3                  if (MIPITX_DPHY == g_stMipiTx.ucTxPhySel)
 716   3                  {
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/11/2025 13:52:36 PAGE 13  

 717   4                      Drv_MipiTx_DPhyClkHsTrig();
 718   4                      Drv_MipiTx_DPhySkewCali();
 719   4                  }
 720   3      
 721   3                  Drv_MipiTx_VideoSet(ON);
 722   3                  Mod_MipiTx_SetState(STATE_MIPITX_AUDIO_OUT_6);
 723   3              }
 724   2              break;
 725   2          case STATE_MIPITX_AUDIO_OUT_6:
 726   2              Drv_Audio_Init();
 727   2      #if TDM_SUPPORT == ENABLED
                      Drv_Audio_TdmOutInit();
              #endif
 730   2              Mod_MipiTx_SetState(STATE_MIPITX_PLAY_BACK_7);
 731   2              break;
 732   2          case STATE_MIPITX_PLAY_BACK_7:
 733   2              break;
 734   2          default:
 735   2              break;
 736   2          }
 737   1      }
 738          
 739          void Mod_MipiTx_Handler(void)
 740          {
 741   1          Mod_MipiTx_StateHandler();
 742   1          Mod_MipiTx_EventProc();
 743   1      }
 744          
 745          void Mod_MIPITx_Pattern(void)
 746          {
 747   1      #if MIPITX_VID_PATTERN_MODE != NO_PATTERN
 748   1          ModPattern_Init();
 749   1          g_stMipiTx.b1UpstreamVideoReady = TRUE;
 750   1          g_stMipiTx.b1UpstreamDeviceReady = TRUE;
 751   1      
 752   1      #if CSC_SUPPORT == ENABLED
              
              #if ((CHIP_SEL == LT6911GXD_HD) || (CHIP_SEL == LT7911UXE_HD))
                  LT6911GXE_HdmiRxCscOrEncSel();
                  LT6911GXE_HdmiRxCscCvt();
              #endif
              
              #if ((CHIP_SEL == LT7911UXE_DP) || (CHIP_SEL == LT6911GXD_DP))
                  LT7911GXE_DpRxCscOrEncSel();
                  LT7911GXE_DpRxCscCvt();
              #endif
              
              #endif
 765   1          while (1)
 766   1          {
 767   2              Mod_MipiTx_Handler();
 768   2          }
 769   1      #endif
 770   1      }
 771          
 772          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3144    ----
   CONSTANT SIZE    =    982    ----
   XDATA SIZE       =    609      53
C51 COMPILER V9.60.0.0   MODMIPITX                                                         11/11/2025 13:52:36 PAGE 14  

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
